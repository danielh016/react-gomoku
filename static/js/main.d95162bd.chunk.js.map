{"version":3,"sources":["imgs/Cross.png","components/Chat/chatStyles.js","components/Chat/components/Input/inputStyles.js","components/Chat/components/Input/input.js","components/Chat/components/Messages/Message/messageStyles.js","components/Chat/components/Messages/Message/message.js","components/Chat/components/Messages/messagesStyles.js","components/Chat/components/Messages/messages.js","components/Chat/components/UserTyping/userTyping.js","components/Chat/chat.js","utils/styleVars.js","utils/constants.js","components/MultiChessBoard/components/Chess/chessStyles.js","components/MultiChessBoard/components/Chess/chess.js","components/MultiChessBoard/chessBoardStyles.js","utils/functions/getWinningChessType.js","utils/functions/reverseChessTurn.js","utils/functions/setEmptyChessMap.js","utils/functions/updateChessMap.js","components/MultiChessBoard/chessBoard.js","components/SingleChessBoard/components/Chess/chessStyles.js","components/SingleChessBoard/components/Chess/chess.js","components/SingleChessBoard/chessBoardStyles.js","utils/aiLogics/countPoints.js","utils/aiLogics/getMaxCountOnThisDirection.js","utils/aiLogics/applyFirstAnalysis.js","utils/aiLogics/applyThirdAnalysis.js","utils/functions/applyAiLogic.js","utils/aiLogics/getFirstPosition.js","utils/aiLogics/initialiseAnalysisRange.js","utils/aiLogics/applySecondComputerAnalysis.js","utils/aiLogics/applySecondHumanAnalysis.js","components/SingleChessBoard/chessBoard.js","components/Dialog/dialogStyles.js","components/Dialog/dialog.js","components/Entry/entryStyles.js","App.js","components/Entry/entry.js","serviceWorker.js","index.js"],"names":["module","exports","ChatContainer","styled","div","Form","form","StyledInput","input","SendButton","button","Input","onKeyDown","setMessage","sendMessage","message","type","placeholder","value","onChange","target","onKeyPress","event","key","onClick","e","MessageBox","props","theme","MessageText","p","MessageContainer","start","end","SentText","left","right","Message","text","user","isSentByCurrentUser","trimmedName","name","trim","toLowerCase","MessagesContainer","ScrollToBottom","Messages","messages","map","i","UserTyping","userTyping","isCurrentUser","status","Chat","socket","useState","setMessages","setUserTyping","useEffect","on","newMessage","prevMessages","timeout","handleTypingTimeout","emit","clearTimeout","setTimeout","preventDefault","colors","CHESS_TYPES","DIRECTIONS","ALIVE_STATES","BOARD_SIZE","COUNT_DIRECTION","ChessContainer","cross","xIndex","yIndex","BlackChess","WhiteChess","EmptyGrid","chessTurn","mouseHovered","hasWon","Chess","chessType","setMouseHovered","mouseHover","handleChessClicked","onMouseEnter","onMouseLeave","renderChessType","defaultProps","ChessBoardContainer","getChessNextToCurrent","currentChess","chessOrder","direction","chessNextToCurrent","find","otherChess","parseInt","checkHasWonWithDirection","numberOfSameTypeInARow","updatedNumberOfSameTypeInARow","WINNING_CONDITION_NUMBER","reachWinningCondition","getWinningChessType","condition","reverseChessTurn","setChessTurn","prevState","setEmptyChessMap","chessMap","x","y","push","toString","updateChessMap","updatedChessMap","forEach","order","mapElement","ChessBoard","firstTurnColor","setChessOrder","pop","chess","pointToNext","pointAttempt","countDirection","updatedPoint","isOutOfWall","checkIncludes","existingPositions","nextPointAttempt","some","existingPosition","countPoints","myExistingPositions","opponentExistingPositions","firstAnalysisResult","updatedFirstAnalysisResult","count","aliveState","isExistingPoint","existingPoints","existingPoint","updateXIndex","point","updateYIndex","updateXYIndex","xValue","yValue","tryAndCalculateResult","computerPointAttempt","maxCountOnThisDirection","counter","currentX","currentY","getMaxCountOnThisDirection","addToFirstAnalysisResult","firstResultMap","has","get","list","set","analysisBestPoint","mySecondAnalysisResults","yourSecondAnalysisResults","length","position","yourResult","commonBestPoint","myResult","applyThirdAnalysis","analysisResults","computer4HalfAlives","bestPoint","human4Alives","computerSecondResults","computerDouble3Alives","humanSecondResults","computer3Alives","humanDouble3Alives","human3Alives","computerDouble2Alives","computer2Alives","computer3HalfAlives","human4HalfAlives","humanDouble2Alives","human2Alives","human3HalfAlives","getBestPoint","computerFirstResultMap","Map","humanFirstResultMap","startAnalysis","getFirstPosition","range","currentRange","rangeMinX","rangeMinY","rangeMaxX","rangeMaxY","initialiseAnalysisRange","allEmptyPoints","filter","getAllEmptyPoints","humanExistingPositions","computerExistingPositions","humanPointAttempt","applyFirstAnalysis","console","log","secondResultsInstance","keys","alive4","alive3","halfAlive4","halfAlive3","alive2","firstResults","result","applySecondComputerAnalysis","applySecondHumanAnalysis","aiChess","parsedChessOrder","aiChessType","nextPosition","applyConditionalAiLogic","sizes","DialogContainer","VictoryMessage","ResetButton","Dialog","chessTypeHasWon","OuterContainer","InnerContainer","Heading","h1","Button","Entry","setName","room","setRoom","to","MultiplayerApp","location","useLocation","FIRST_TURN_COLOR","queryString","parse","search","urlName","urlRoom","io","error","alert","SingleplayerApp","RouterApp","path","element","Boolean","window","hostname","match","ReactDOM","render","StrictMode","App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.d95162bd.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFIAAABSCAYAAADHLIObAAADwnRFWHRteGZpbGUAJTNDbXhmaWxlJTIwaG9zdCUzRCUyMmFwcC5kaWFncmFtcy5uZXQlMjIlMjBtb2RpZmllZCUzRCUyMjIwMjAtMDgtMjdUMDElM0EzNiUzQTQ3LjY5MFolMjIlMjBhZ2VudCUzRCUyMjUuMCUyMChNYWNpbnRvc2glM0IlMjBJbnRlbCUyME1hYyUyME9TJTIwWCUyMDEwXzE1XzUpJTIwQXBwbGVXZWJLaXQlMkY1MzcuMzYlMjAoS0hUTUwlMkMlMjBsaWtlJTIwR2Vja28pJTIwQ2hyb21lJTJGODQuMC40MTQ3LjEyNSUyMFNhZmFyaSUyRjUzNy4zNiUyMiUyMGV0YWclM0QlMjJPUWZpQjJPai16S2dRUUVKei1hUSUyMiUyMHZlcnNpb24lM0QlMjIxMy40LjIlMjIlMjB0eXBlJTNEJTIyZ29vZ2xlJTIyJTNFJTNDZGlhZ3JhbSUyMGlkJTNEJTIyWDhRTjZMM3VQYmhVTXZ6NUttUnglMjIlMjBuYW1lJTNEJTIyUGFnZS0xJTIyJTNFM1pSZFQ4SXdGSVolMkZ6UzVOdG5XZ1hncE1UUWlKU295WHBxN0hyYkZyU2VtQThlc3Q5T3lqTEFieDBxdTFUMCUyRmYwJTJGT2VyZ0dabHJzSFRWZkZRakVRUVJ5eVhVQm1RUnhIU1R5Mm53T3BIYmtKaVFPNTVneURPckRrZTBBWUlxMDRnN1VYYUpRU2hxOThtQ2twSVRNZW8xcXJyUiUyRjJxWVNmZFVWekdJQmxSc1dRdm5GbUNxd2l2dTc0SSUyRkM4YURKSDQxdTM4a0d6cjF5clNtSSUyQnFTUzRsWkkyTWxqanVxQk1iWHVJcEFHWmFxV01HNVc3S1lpRHJZMWpidCUyRjlENnZ0a1RWSTg1c044M1NldlU3MnolMkZGN05XTXBwYU9GZkxsQ2xRMFZGVnFCaHpWMTR3MUlkbmV3Mk02TzFaRkpZVXBoWjVFZHVtaGdBM3U3VTBWdHJmYjZnQ3JCNk5xR2JEdWZSJTJCaFEwYk80WVJvRU5Yemp5MU5zZDk3S3RSbWVGTGVKNHhDdlpoS2lEbDdNSkFsOWliV3FkQWE0cSUyQiUyRmVHU0V5UGhFeVZPZGdCa0oyMEN1N1E4Zm1YTkFvOHM4YjFmcFpuJTJGaDljYU9TTTBKJTJGYnBTZGRuJTJCckMlMkI5ZVE1SiUyQkF3JTNEJTNEJTNDJTJGZGlhZ3JhbSUzRSUzQyUyRm14ZmlsZSUzRYZp158AAAE0SURBVHhe7d1BCsJAEEXBzsnVkyuDV6hFh7yA28dY+dsh1+x/3jNzfqufa/Xp/of7zsz6c64/YJBu6i0SWQYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRb5NMhzh+WF/vQTM59zD6jrIejVBxkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZOyyy79mgl32LzA8BqVJT/CwcjQAAAABJRU5ErkJggg==\"","import styled from 'styled-components';\n\nconst sizes = {\n  borderWidth: '3px',\n};\n\nexport const ChatContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  height: 70vh;\n  left: 100vh;\n\n  position: absolute;\n  top: 30vh;\n  width: calc(100vw - 100vh - 2 * ${sizes.borderWidth});\n`;\n","import styled from 'styled-components';\n\nexport const Form = styled.form`\n  display: flex;\n  border-top: 2px solid #d3d3d3;\n`;\n\nexport const StyledInput = styled.input`\n  border: none;\n  border-radius: 0;\n  padding: 2%;\n  width: 80%;\n  font-size: 1.2em;\n\n  :focus {\n    outline: none;\n  }\n`;\n\nexport const SendButton = styled.button`\n  color: #fff !important;\n  cursor: pointer;\n  text-transform: uppercase;\n  text-decoration: none;\n  background: green;\n  padding: 10px;\n  display: inline-block;\n  border: none;\n  width: 20%;\n\n  :hover {\n    opacity: 0.8;\n  }\n`;\n","import React from 'react';\nimport { Form, SendButton, StyledInput } from './inputStyles';\n\n// TODO: use formik here\nconst Input = ({ onKeyDown, setMessage, sendMessage, message }) => (\n  <Form>\n    <StyledInput\n      type=\"text\"\n      placeholder=\"Type a message...\"\n      value={message}\n      onChange={({ target: { value } }) => setMessage(value)}\n      onKeyDown={onKeyDown}\n      onKeyPress={(event) => (event.key === 'Enter' ? sendMessage(event) : null)}\n    />\n    <SendButton onClick={(e) => sendMessage(e)}>Send</SendButton>\n  </Form>\n);\n\nexport default Input;\n","import styled from 'styled-components';\n\nexport const MessageBox = styled.div`\n  background: ${(props) => {\n    if (props.theme === 'dark') return '#2979FF';\n    if (props.theme === 'light') return '#F3F3F3';\n    return '#F3F3F3';\n  }};\n  border-radius: 20px;\n  padding: 5px 20px;\n  color: white;\n  display: inline-block;\n  max-width: 80%;\n`;\n\nexport const MessageText = styled.p`\n  color: ${(props) => {\n    if (props.theme === 'dark') return 'white';\n    if (props.theme === 'light') return '#353535';\n    return '#353535';\n  }};\n  width: 100%;\n  letter-spacing: 0;\n  float: left;\n  font-size: 1.1em;\n  word-wrap: break-word;\n\n  img {\n    vertical-align: middle;\n  }\n`;\n\nexport const MessageContainer = styled.div`\n  display: flex;\n  justify-content: ${(props) => {\n    if (props.start) return 'flex-start';\n    if (props.end) return 'flex-end';\n    return 'flex-end';\n  }};\n  padding: 0 5%;\n  margin-top: 3px;\n`;\n\nexport const SentText = styled.p`\n  display: flex;\n  align-items: center;\n  font-family: Helvetica;\n  color: #828282;\n  letter-spacing: 0.3px;\n\n  padding-left: ${(props) => (props.left ? '10px' : '0')};\n  padding-right: ${(props) => (props.right ? '10px' : '0')};\n`;\n","/* eslint-disable react/prop-types */\nimport React from 'react';\nimport { MessageBox, MessageContainer, MessageText, SentText } from './messageStyles';\n\nconst Message = ({ message: { text, user }, name }) => {\n  let isSentByCurrentUser = false;\n\n  const trimmedName = name.trim().toLowerCase();\n\n  if (user === trimmedName) {\n    isSentByCurrentUser = true;\n  }\n\n  return isSentByCurrentUser ? (\n    <MessageContainer end>\n      <SentText right>{trimmedName}</SentText>\n      <MessageBox theme=\"dark\">\n        <MessageText theme=\"dark\">{text}</MessageText>\n      </MessageBox>\n    </MessageContainer>\n  ) : (\n    <MessageContainer start>\n      <MessageBox theme=\"light\">\n        <MessageText theme=\"light\">{text}</MessageText>\n      </MessageBox>\n      <SentText left>{user}</SentText>\n    </MessageContainer>\n  );\n};\n\nexport default Message;\n","import ScrollToBottom from 'react-scroll-to-bottom';\nimport styled from 'styled-components';\n\nexport const MessagesContainer = styled(ScrollToBottom)`\n  padding: 5% 0;\n  overflow: auto;\n  flex: auto;\n`;\n","import React from 'react';\nimport Message from './Message';\nimport { MessagesContainer } from './messagesStyles';\n\nconst Messages = ({ messages, name }) => (\n  <MessagesContainer>\n    {messages.map((message, i) => (\n      <div key={i}>\n        <Message message={message} name={name} />\n      </div>\n    ))}\n  </MessagesContainer>\n);\n\nexport default Messages;\n","/* eslint-disable react/prop-types */\nimport React from 'react';\n\nconst UserTyping = ({ userTyping, name }) => {\n  const trimmedName = name.trim().toLowerCase();\n  let isCurrentUser = false;\n\n  if (userTyping.user === trimmedName) {\n    isCurrentUser = true;\n  }\n\n  if (userTyping.status && !isCurrentUser) {\n    return <>{userTyping.user} is typing...</>;\n  }\n  return <></>;\n};\n\nexport default UserTyping;\n","import React, { useEffect, useState } from 'react';\nimport { ChatContainer } from './chatStyles';\nimport Input from './components/Input';\nimport Messages from './components/Messages';\nimport UserTyping from './components/UserTyping';\n\nconst Chat = ({ name, socket }) => {\n  const [message, setMessage] = useState('');\n  const [messages, setMessages] = useState([]);\n  const [userTyping, setUserTyping] = useState({});\n\n  useEffect(() => {\n    if (socket) {\n      socket.on('message', (newMessage) => {\n        setMessages((prevMessages) => [...prevMessages, newMessage]);\n      });\n      socket.on('typing', ({ user, status }) => {\n        setUserTyping({ user, status });\n      });\n    }\n  }, [socket]);\n\n  const sendMessage = (event) => {\n    event.preventDefault();\n\n    if (message) {\n      socket.emit('sendMessage', message, () => setMessage(''));\n    }\n  };\n\n  let timeout;\n\n  const handleTypingTimeout = () => {\n    socket.emit('typing', { status: false });\n  };\n\n  const handleKeyDown = () => {\n    socket.emit('typing', { status: true });\n    clearTimeout(timeout);\n    timeout = setTimeout(handleTypingTimeout, 5000);\n  };\n\n  return (\n    <ChatContainer>\n      <Messages messages={messages} name={name} />\n      <UserTyping userTyping={userTyping} name={name} />\n      <Input\n        message={message}\n        onKeyDown={handleKeyDown}\n        setMessage={setMessage}\n        sendMessage={sendMessage}\n      />\n    </ChatContainer>\n  );\n};\n\nexport default Chat;\n","// eslint-disable-next-line import/prefer-default-export\nexport const colors = {\n  chessboardBrown: '#A5682A',\n  black: '#000000',\n  red: '#C73B0F',\n  white: '#ffffff',\n};\n","export const CHESS_TYPES = {\n  BLACK: 'BLACK',\n  WHITE: 'WHITE',\n  EMPTY: 'EMPTY',\n};\n\nexport const DIRECTIONS = {\n  HORIZONTAL: 'HORIZONTAL',\n  VERTICAL: 'VERTICAL',\n  DIAGONAL_TOPLEFT_BOTTOMRIGHT: 'DIAGONAL_TOPLEFT_BOTTOMRIGHT',\n  DIAGONAL_TOPRIGHT_BOTTOMLEFT: 'DIAGONAL_TOPRIGHT_BOTTOMLEFT',\n};\n\nexport const ALIVE_STATES = {\n  ALIVE: 'ALIVE',\n  HALF_ALIVE: 'HALF_ALIVE',\n};\n\nexport const BOARD_SIZE = {\n  MIN_X: 0,\n  MIN_Y: 0,\n  MAX_X: 14,\n  MAX_Y: 14,\n};\n\nexport const COUNT_DIRECTION = {\n  FORWARD: 'FORWARD',\n  BACKWARD: 'BACKWARD',\n};\n","import styled from 'styled-components';\nimport { colors } from '../../../../utils/styleVars';\nimport { CHESS_TYPES } from '../../../../utils/constants';\nimport cross from '../../../../imgs/Cross.png';\n\nexport const ChessContainer = styled.div`\n  align-items: center;\n  background-image: url(${cross});\n  background-position: center;\n  display: flex;\n  height: calc(100vh / 15);\n  justify-content: center;\n  left: calc(100vh / 15 * ${(props) => props.xIndex});\n  position: absolute;\n  top: calc(100vh / 15 * ${(props) => props.yIndex});\n  width: calc(100vh / 15);\n  z-index: 1;\n`;\n\nexport const BlackChess = styled.div`\n  background-color: ${colors.black};\n  border-radius: 100%;\n  height: 70%;\n  width: 70%;\n`;\n\nexport const WhiteChess = styled.div`\n  background-color: ${colors.white};\n  border-radius: 100%;\n  height: 70%;\n  width: 70%;\n`;\n\nexport const EmptyGrid = styled.div`\n  border-color: ${(props) => (props.chessTurn === CHESS_TYPES.BLACK ? colors.black : colors.white)};\n  border-style: ${(props) => (props.mouseHovered && !props.hasWon ? 'solid' : 'none')};\n  height: 100%;\n  width: 100%;\n`;\n","import React, { useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { ChessContainer, BlackChess, WhiteChess, EmptyGrid } from './chessStyles';\nimport { CHESS_TYPES } from '../../../../utils/constants';\n\nconst Chess = ({ chessType, chessTurn, xIndex, yIndex, hasWon, socket }) => {\n  const [mouseHovered, setMouseHovered] = useState(false);\n\n  const mouseHover = () => {\n    setMouseHovered(!mouseHovered);\n  };\n\n  const handleChessClicked = () => {\n    socket.emit('addChessOrder', { xIndex, yIndex, chessType: chessTurn });\n  };\n\n  const renderChessType = (type) => {\n    switch (type) {\n      case CHESS_TYPES.BLACK:\n        return <BlackChess />;\n      case CHESS_TYPES.WHITE:\n        return <WhiteChess />;\n      case CHESS_TYPES.EMPTY:\n        return (\n          <EmptyGrid\n            onMouseEnter={mouseHover}\n            onMouseLeave={mouseHover}\n            mouseHovered={mouseHovered}\n            hasWon={hasWon}\n            chessTurn={chessTurn}\n            onClick={hasWon ? () => {} : handleChessClicked}\n          />\n        );\n      default:\n        return <EmptyGrid />;\n    }\n  };\n\n  return (\n    <ChessContainer xIndex={xIndex} yIndex={yIndex}>\n      {renderChessType(chessType)}\n    </ChessContainer>\n  );\n};\n\nChess.propTypes = {\n  chessType: PropTypes.string,\n  chessTurn: PropTypes.string.isRequired,\n  xIndex: PropTypes.string.isRequired,\n  yIndex: PropTypes.string.isRequired,\n  hasWon: PropTypes.bool.isRequired,\n};\n\nChess.defaultProps = {\n  chessType: 'empty',\n};\n\nexport default Chess;\n","import styled from 'styled-components';\nimport { colors } from '../../utils/styleVars';\n\n// eslint-disable-next-line import/prefer-default-export\nexport const ChessBoardContainer = styled.div`\n  background-color: ${colors.chessboardBrown};\n  height: 100vh;\n  left: 0\n  position: absolute;\n  top: 0;\n  width: 100vh;\n  z-index: 0;\n`;\n","import { DIRECTIONS } from '../constants';\n\nconst getChessNextToCurrent = (currentChess, chessOrder, direction) => {\n  let chessNextToCurrent = null;\n\n  switch (direction) {\n    case DIRECTIONS.HORIZONTAL: {\n      chessNextToCurrent = chessOrder.find(\n        (otherChess) =>\n          parseInt(otherChess.xIndex, 10) === parseInt(currentChess.xIndex, 10) + 1 &&\n          parseInt(otherChess.yIndex, 10) === parseInt(currentChess.yIndex, 10)\n      );\n      break;\n    }\n    case DIRECTIONS.VERTICAL: {\n      chessNextToCurrent = chessOrder.find(\n        (otherChess) =>\n          parseInt(otherChess.xIndex, 10) === parseInt(currentChess.xIndex, 10) &&\n          parseInt(otherChess.yIndex, 10) === parseInt(currentChess.yIndex, 10) + 1\n      );\n      break;\n    }\n    case DIRECTIONS.DIAGONAL_TOPLEFT_BOTTOMRIGHT: {\n      chessNextToCurrent = chessOrder.find(\n        (otherChess) =>\n          parseInt(otherChess.xIndex, 10) === parseInt(currentChess.xIndex, 10) + 1 &&\n          parseInt(otherChess.yIndex, 10) === parseInt(currentChess.yIndex, 10) + 1\n      );\n      break;\n    }\n    case DIRECTIONS.DIAGONAL_TOPRIGHT_BOTTOMLEFT: {\n      chessNextToCurrent = chessOrder.find(\n        (otherChess) =>\n          parseInt(otherChess.xIndex, 10) === parseInt(currentChess.xIndex, 10) + 1 &&\n          parseInt(otherChess.yIndex, 10) === parseInt(currentChess.yIndex, 10) - 1\n      );\n      break;\n    }\n    default:\n  }\n\n  return chessNextToCurrent;\n};\n\nconst checkHasWonWithDirection = (\n  currentChess,\n  chessOrder,\n  direction,\n  numberOfSameTypeInARow = 1\n) => {\n  let updatedNumberOfSameTypeInARow = numberOfSameTypeInARow;\n\n  const chessNextToCurrent = getChessNextToCurrent(currentChess, chessOrder, direction);\n\n  if (!chessNextToCurrent) return false;\n\n  const WINNING_CONDITION_NUMBER = 5;\n\n  if (chessNextToCurrent.chessType === currentChess.chessType) {\n    updatedNumberOfSameTypeInARow += 1;\n    const reachWinningCondition = updatedNumberOfSameTypeInARow === WINNING_CONDITION_NUMBER;\n\n    if (reachWinningCondition) return true;\n    return checkHasWonWithDirection(\n      chessNextToCurrent,\n      chessOrder,\n      direction,\n      updatedNumberOfSameTypeInARow\n    );\n  }\n\n  return false;\n};\n\nconst getWinningChessType = (chessOrder) => {\n  const hasWonConditionList = chessOrder.map((currentChess) => {\n    const hasWon =\n      checkHasWonWithDirection(currentChess, chessOrder, DIRECTIONS.HORIZONTAL) ||\n      checkHasWonWithDirection(currentChess, chessOrder, DIRECTIONS.VERTICAL) ||\n      checkHasWonWithDirection(currentChess, chessOrder, DIRECTIONS.DIAGONAL_TOPLEFT_BOTTOMRIGHT) ||\n      checkHasWonWithDirection(currentChess, chessOrder, DIRECTIONS.DIAGONAL_TOPRIGHT_BOTTOMLEFT);\n    if (hasWon) {\n      return currentChess.chessType;\n    }\n    return null;\n  });\n\n  const chessTypeHasWon = hasWonConditionList.find((condition) => condition !== null);\n  return chessTypeHasWon;\n};\n\nexport default getWinningChessType;\n","import { CHESS_TYPES } from '../constants';\n\nconst reverseChessTurn = (setChessTurn) => {\n  setChessTurn((prevState) => {\n    if (prevState === CHESS_TYPES.BLACK) {\n      setChessTurn(CHESS_TYPES.WHITE);\n    }\n    if (prevState === CHESS_TYPES.WHITE) {\n      setChessTurn(CHESS_TYPES.BLACK);\n    }\n  });\n};\n\nexport default reverseChessTurn;\n","import { CHESS_TYPES } from '../constants';\n\nconst setEmptyChessMap = () => {\n  const chessMap = [];\n  for (let x = 0; x < 15; x += 1) {\n    for (let y = 0; y < 15; y += 1) {\n      chessMap.push({\n        xIndex: x.toString(),\n        yIndex: y.toString(),\n        chessType: CHESS_TYPES.EMPTY,\n      });\n    }\n  }\n  return chessMap;\n};\n\nexport default setEmptyChessMap;\n","const updateChessMap = (chessOrder, chessMap) => {\n  const updatedChessMap = chessMap;\n  chessOrder.forEach((order) => {\n    updatedChessMap.forEach((mapElement) => {\n      if (order.xIndex === mapElement.xIndex && order.yIndex === mapElement.yIndex) {\n        // eslint-disable-next-line no-param-reassign\n        mapElement.chessType = order.chessType;\n      }\n    });\n  });\n};\n\nexport default updateChessMap;\n","import React, { useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { Chess } from './components';\nimport { ChessBoardContainer } from './chessBoardStyles';\nimport { reverseChessTurn } from '../../utils/functions';\n\nconst ChessBoard = ({\n  firstTurnColor,\n  chessMap,\n  chessTurn,\n  hasWon,\n  setChessOrder,\n  setChessTurn,\n  socket,\n}) => {\n  useEffect(() => {\n    if (socket) {\n      socket.on('updateChessOrder', ({ xIndex, yIndex, chessType }) => {\n        setChessOrder((prevState) => [\n          ...prevState,\n          { xIndex: `${xIndex}`, yIndex: `${yIndex}`, chessType },\n        ]);\n        reverseChessTurn(setChessTurn);\n      });\n\n      socket.on('resetChessMap', () => {\n        setChessOrder([]);\n        setChessTurn(firstTurnColor);\n      });\n\n      socket.on('undoChessAction', () => {\n        setChessOrder((prevState) => {\n          prevState.pop();\n          return [...prevState];\n        });\n        reverseChessTurn(setChessTurn);\n      });\n    }\n  }, [socket, firstTurnColor, setChessOrder, setChessTurn]);\n\n  return (\n    <ChessBoardContainer>\n      {chessMap.map((chess) => (\n        <Chess\n          key={`${chess.chessType}-${chess.xIndex}-${chess.yIndex}`}\n          chessType={chess.chessType}\n          chessTurn={chessTurn}\n          xIndex={chess.xIndex}\n          yIndex={chess.yIndex}\n          hasWon={hasWon}\n          socket={socket}\n        />\n      ))}\n    </ChessBoardContainer>\n  );\n};\n\nChessBoard.propTypes = {\n  chessMap: PropTypes.arrayOf(PropTypes.shape()).isRequired,\n  chessTurn: PropTypes.string.isRequired,\n  hasWon: PropTypes.bool.isRequired,\n  setChessOrder: PropTypes.func.isRequired,\n  setChessTurn: PropTypes.func.isRequired,\n};\n\nexport default ChessBoard;\n","import styled from 'styled-components';\nimport { colors } from '../../../../utils/styleVars';\nimport { CHESS_TYPES } from '../../../../utils/constants';\nimport cross from '../../../../imgs/Cross.png';\n\nexport const ChessContainer = styled.div`\n  align-items: center;\n  background-image: url(${cross});\n  background-position: center;\n  display: flex;\n  height: calc(100vh / 15);\n  justify-content: center;\n  left: calc(100vh / 15 * ${(props) => props.xIndex});\n  position: absolute;\n  top: calc(100vh / 15 * ${(props) => props.yIndex});\n  width: calc(100vh / 15);\n  z-index: 1;\n`;\n\nexport const BlackChess = styled.div`\n  background-color: ${colors.black};\n  border-radius: 100%;\n  height: 70%;\n  width: 70%;\n`;\n\nexport const WhiteChess = styled.div`\n  background-color: ${colors.white};\n  border-radius: 100%;\n  height: 70%;\n  width: 70%;\n`;\n\nexport const EmptyGrid = styled.div`\n  border-color: ${(props) => (props.chessTurn === CHESS_TYPES.BLACK ? colors.black : colors.white)};\n  border-style: ${(props) => (props.mouseHovered && !props.hasWon ? 'solid' : 'none')};\n  height: 100%;\n  width: 100%;\n`;\n","import React, { useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { ChessContainer, BlackChess, WhiteChess, EmptyGrid } from './chessStyles';\nimport { CHESS_TYPES } from '../../../../utils/constants';\nimport { reverseChessTurn } from '../../../../utils/functions';\n\nconst Chess = ({ chessType, chessTurn, xIndex, yIndex, hasWon, setChessOrder, setChessTurn }) => {\n  const [mouseHovered, setMouseHovered] = useState(false);\n\n  const mouseHover = () => {\n    setMouseHovered(!mouseHovered);\n  };\n\n  const handleChessClicked = () => {\n    setChessOrder((prevState) => [\n      ...prevState,\n      { xIndex: `${xIndex}`, yIndex: `${yIndex}`, chessType: chessTurn },\n    ]);\n    reverseChessTurn(setChessTurn);\n  };\n\n  const renderChessType = (type) => {\n    switch (type) {\n      case CHESS_TYPES.BLACK:\n        return <BlackChess />;\n      case CHESS_TYPES.WHITE:\n        return <WhiteChess />;\n      case CHESS_TYPES.EMPTY:\n        return (\n          <EmptyGrid\n            onMouseEnter={mouseHover}\n            onMouseLeave={mouseHover}\n            mouseHovered={mouseHovered}\n            hasWon={hasWon}\n            chessTurn={chessTurn}\n            onClick={hasWon ? () => {} : handleChessClicked}\n          />\n        );\n      default:\n        return <EmptyGrid />;\n    }\n  };\n\n  return (\n    <ChessContainer xIndex={xIndex} yIndex={yIndex}>\n      {renderChessType(chessType)}\n    </ChessContainer>\n  );\n};\n\nChess.propTypes = {\n  chessType: PropTypes.string,\n  chessTurn: PropTypes.string.isRequired,\n  xIndex: PropTypes.string.isRequired,\n  yIndex: PropTypes.string.isRequired,\n  hasWon: PropTypes.bool.isRequired,\n  setChessOrder: PropTypes.func.isRequired,\n  setChessTurn: PropTypes.func.isRequired,\n};\n\nChess.defaultProps = {\n  chessType: 'empty',\n};\n\nexport default Chess;\n","import styled from 'styled-components';\nimport { colors } from '../../utils/styleVars';\n\n// eslint-disable-next-line import/prefer-default-export\nexport const ChessBoardContainer = styled.div`\n  background-color: ${colors.chessboardBrown};\n  height: 100vh;\n  left: 0;\n  position: absolute;\n  top: 0;\n  width: 100vh;\n  z-index: 0;\n`;\n","import { ALIVE_STATES, BOARD_SIZE, COUNT_DIRECTION, DIRECTIONS } from '../constants';\n\n/* eslint-disable complexity */\nconst pointToNext = (pointAttempt, direction, countDirection) => {\n  const updatedPoint = { ...pointAttempt };\n  switch (direction) {\n    case DIRECTIONS.HORIZONTAL: {\n      if (countDirection === COUNT_DIRECTION.FORWARD) {\n        updatedPoint.xIndex += 1;\n      } else {\n        updatedPoint.xIndex -= 1;\n      }\n      return updatedPoint;\n    }\n    case DIRECTIONS.VERTICAL: {\n      if (countDirection === COUNT_DIRECTION.FORWARD) {\n        updatedPoint.yIndex += 1;\n      } else {\n        updatedPoint.yIndex -= 1;\n      }\n      return updatedPoint;\n    }\n    case DIRECTIONS.DIAGONAL_TOPLEFT_BOTTOMRIGHT: {\n      if (countDirection === COUNT_DIRECTION.FORWARD) {\n        updatedPoint.xIndex += 1;\n        updatedPoint.yIndex += 1;\n      } else {\n        updatedPoint.xIndex -= 1;\n        updatedPoint.yIndex -= 1;\n      }\n      return updatedPoint;\n    }\n    case DIRECTIONS.DIAGONAL_TOPRIGHT_BOTTOMLEFT: {\n      if (countDirection === COUNT_DIRECTION.FORWARD) {\n        updatedPoint.xIndex += 1;\n        updatedPoint.yIndex -= 1;\n      } else {\n        updatedPoint.xIndex -= 1;\n        updatedPoint.yIndex += 1;\n      }\n      return updatedPoint;\n    }\n    default: {\n      break;\n    }\n  }\n\n  return updatedPoint;\n};\n\nconst isOutOfWall = (pointAttempt, direction) => {\n  if (direction === DIRECTIONS.VERTICAL) {\n    return pointAttempt.yIndex < BOARD_SIZE.MIN_Y || pointAttempt.yIndex >= BOARD_SIZE.MAX_Y;\n  }\n  if (direction === DIRECTIONS.HORIZONTAL) {\n    return pointAttempt.xIndex < BOARD_SIZE.MIN_X || pointAttempt.xIndex >= BOARD_SIZE.MAX_X;\n  }\n  return (\n    pointAttempt.xIndex < BOARD_SIZE.MIN_X ||\n    pointAttempt.xIndex >= BOARD_SIZE.MAX_X ||\n    pointAttempt.yIndex < BOARD_SIZE.MIN_Y ||\n    pointAttempt.yIndex >= BOARD_SIZE.MAX_Y\n  );\n};\n\nconst checkIncludes = (existingPositions, nextPointAttempt) => {\n  return existingPositions.some(\n    (existingPosition) =>\n      existingPosition.xIndex === nextPointAttempt.xIndex &&\n      existingPosition.yIndex === nextPointAttempt.yIndex\n  );\n};\n\nexport const countPoints = (\n  myExistingPositions,\n  opponentExistingPositions,\n  pointAttempt,\n  firstAnalysisResult,\n  direction,\n  countDirection\n) => {\n  const updatedFirstAnalysisResult = firstAnalysisResult;\n  let nextPointAttempt = pointToNext(pointAttempt, direction, countDirection);\n\n  if (checkIncludes(myExistingPositions, nextPointAttempt)) {\n    updatedFirstAnalysisResult.count += 1;\n    nextPointAttempt = pointToNext(nextPointAttempt, direction, countDirection);\n\n    if (checkIncludes(myExistingPositions, nextPointAttempt)) {\n      updatedFirstAnalysisResult.count += 1;\n      nextPointAttempt = pointToNext(nextPointAttempt, direction, countDirection);\n\n      if (checkIncludes(myExistingPositions, nextPointAttempt)) {\n        updatedFirstAnalysisResult.count += 1;\n        nextPointAttempt = pointToNext(nextPointAttempt, direction, countDirection);\n\n        if (checkIncludes(myExistingPositions, nextPointAttempt)) {\n          updatedFirstAnalysisResult.count += 1;\n          nextPointAttempt = pointToNext(nextPointAttempt, direction, countDirection);\n        } else if (\n          checkIncludes(opponentExistingPositions, nextPointAttempt) ||\n          isOutOfWall(nextPointAttempt, direction)\n        ) {\n          updatedFirstAnalysisResult.aliveState = ALIVE_STATES.HALF_ALIVE;\n        }\n      } else if (\n        checkIncludes(opponentExistingPositions, nextPointAttempt) ||\n        isOutOfWall(nextPointAttempt, direction)\n      ) {\n        updatedFirstAnalysisResult.aliveState = ALIVE_STATES.HALF_ALIVE;\n      }\n    } else if (\n      checkIncludes(opponentExistingPositions, nextPointAttempt) ||\n      isOutOfWall(nextPointAttempt, direction)\n    ) {\n      updatedFirstAnalysisResult.aliveState = ALIVE_STATES.HALF_ALIVE;\n    }\n  } else if (\n    checkIncludes(opponentExistingPositions, nextPointAttempt) ||\n    isOutOfWall(nextPointAttempt, direction)\n  ) {\n    updatedFirstAnalysisResult.aliveState = ALIVE_STATES.HALF_ALIVE;\n  }\n\n  return updatedFirstAnalysisResult;\n};\n","/* eslint-disable complexity */\n\nimport { BOARD_SIZE, DIRECTIONS } from '../constants';\n\nfunction isExistingPoint(pointAttempt, existingPoints) {\n  return existingPoints.some(\n    (existingPoint) =>\n      existingPoint.xIndex === pointAttempt.xIndex && existingPoint.yIndex === pointAttempt.yIndex\n  );\n}\n\nfunction updateXIndex(point, value) {\n  return { ...point, xIndex: value };\n}\n\nfunction updateYIndex(point, value) {\n  return { ...point, yIndex: value };\n}\n\nfunction updateXYIndex(point, xValue, yValue) {\n  return { ...point, xIndex: xValue, yIndex: yValue };\n}\n\nexport const getMaxCountOnThisDirection = (pointAttempt, existingPositions, direction, count) => {\n  let counter = count;\n  const x = pointAttempt.xIndex;\n  const y = pointAttempt.yIndex;\n\n  let currentX = pointAttempt.xIndex;\n  let currentY = pointAttempt.yIndex;\n\n  switch (direction) {\n    case DIRECTIONS.HORIZONTAL: {\n      while (\n        currentX >= 0 &&\n        !isExistingPoint(updateXIndex(pointAttempt, currentX - 1), existingPositions)\n      ) {\n        counter += 1;\n        currentX -= 1;\n      }\n      currentX = x;\n      while (\n        currentX <= BOARD_SIZE.MAX_X &&\n        !isExistingPoint(updateXIndex(pointAttempt, currentX + 1), existingPositions) &&\n        counter < 6\n      ) {\n        counter += 1;\n        currentX += 1;\n      }\n\n      break;\n    }\n    case DIRECTIONS.VERTICAL: {\n      while (\n        currentY >= 0 &&\n        !isExistingPoint(updateYIndex(pointAttempt, currentY - 1), existingPositions)\n      ) {\n        counter += 1;\n        currentY -= 1;\n      }\n      currentY = x;\n      while (\n        currentY <= BOARD_SIZE.MAX_Y &&\n        !isExistingPoint(updateYIndex(pointAttempt, currentY + 1), existingPositions) &&\n        counter < 6\n      ) {\n        counter += 1;\n        currentY += 1;\n      }\n\n      break;\n    }\n    case DIRECTIONS.DIAGONAL_TOPLEFT_BOTTOMRIGHT: {\n      while (\n        currentX >= 0 &&\n        currentY >= 0 &&\n        !isExistingPoint(updateXYIndex(pointAttempt, currentX - 1, currentY - 1), existingPositions)\n      ) {\n        counter += 1;\n        currentX -= 1;\n        currentY -= 1;\n      }\n      currentX = x;\n      currentY = y;\n      while (\n        currentX < BOARD_SIZE.MAX_X &&\n        currentY < BOARD_SIZE.MAX_Y &&\n        !isExistingPoint(\n          updateXYIndex(pointAttempt, currentX + 1, currentY + 1),\n          existingPositions\n        ) &&\n        counter < 6\n      ) {\n        counter += 1;\n        currentX += 1;\n        currentY += 1;\n      }\n      break;\n    }\n    case DIRECTIONS.DIAGONAL_TOPRIGHT_BOTTOMLEFT: {\n      while (\n        currentX >= 0 &&\n        currentY < BOARD_SIZE.MAX_Y &&\n        !isExistingPoint(updateXYIndex(pointAttempt, currentX - 1, currentY + 1), existingPositions)\n      ) {\n        counter += 1;\n        currentX -= 1;\n        currentY += 1;\n      }\n      currentX = x;\n      currentY = y;\n      while (\n        currentX < BOARD_SIZE.MAX_X &&\n        currentY >= 0 &&\n        !isExistingPoint(\n          updateXYIndex(pointAttempt, currentX + 1, currentY - 1),\n          existingPositions\n        ) &&\n        counter < 6\n      ) {\n        counter += 1;\n        currentX += 1;\n        currentY -= 1;\n      }\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n\n  return counter;\n};\n","/* eslint-disable no-continue */\n/* eslint-disable complexity */\n\nimport { ALIVE_STATES, COUNT_DIRECTION, DIRECTIONS } from '../constants';\nimport { countPoints } from './countPoints';\nimport { getMaxCountOnThisDirection } from './getMaxCountOnThisDirection';\n\nconst tryAndCalculateResult = (\n  myExistingPositions,\n  opponentExistingPositions,\n  computerPointAttempt,\n  direction\n) => {\n  let firstAnalysisResult = {};\n\n  const maxCountOnThisDirection = getMaxCountOnThisDirection(\n    computerPointAttempt,\n    opponentExistingPositions,\n    direction,\n    1\n  );\n\n  if (maxCountOnThisDirection < 5) {\n    return null;\n  }\n  if (maxCountOnThisDirection === 5) {\n    firstAnalysisResult = {\n      count: 1,\n      point: computerPointAttempt,\n      direction,\n      aliveState: ALIVE_STATES.HALF_ALIVE,\n    };\n  } else {\n    firstAnalysisResult = {\n      count: 1,\n      point: computerPointAttempt,\n      direction,\n      aliveState: ALIVE_STATES.ALIVE,\n    };\n  }\n\n  firstAnalysisResult = countPoints(\n    myExistingPositions,\n    opponentExistingPositions,\n    computerPointAttempt,\n    firstAnalysisResult,\n    direction,\n    COUNT_DIRECTION.FORWARD\n  );\n  firstAnalysisResult = countPoints(\n    myExistingPositions,\n    opponentExistingPositions,\n    computerPointAttempt,\n    firstAnalysisResult,\n    direction,\n    COUNT_DIRECTION.BACKWARD\n  );\n\n  if (\n    firstAnalysisResult.count <= 1 ||\n    (firstAnalysisResult.count === 2 && firstAnalysisResult.aliveState === ALIVE_STATES.HALF_ALIVE)\n  ) {\n    return null;\n  }\n\n  return firstAnalysisResult;\n};\n\nconst addToFirstAnalysisResult = (firstAnalysisResult, firstResultMap) => {\n  const { point } = firstAnalysisResult;\n\n  if (firstResultMap.has(point)) {\n    firstResultMap.get(point).push(firstAnalysisResult);\n  } else {\n    const list = [firstAnalysisResult];\n    firstResultMap.set(point, list);\n  }\n};\n\nexport const applyFirstAnalysis = (\n  computerExistingPositions,\n  humanExistingPositions,\n  allEmptyPoints,\n  range,\n  computerFirstResultMap,\n  humanFirstResultMap\n) => {\n  let computerPointAttempt = null;\n  let humanPointAttempt = null;\n  let x;\n  let y;\n  let firstAnalysisResult;\n\n  for (let i = 0; i < allEmptyPoints.length; i += 1) {\n    computerPointAttempt = allEmptyPoints[i];\n    x = computerPointAttempt.xIndex;\n    y = computerPointAttempt.yIndex;\n\n    if (x < range.rangeMinX || x > range.rangeMaxX || y < range.rangeMinY || y > range.rangeMaxY) {\n      continue;\n    }\n\n    firstAnalysisResult = tryAndCalculateResult(\n      computerExistingPositions,\n      humanExistingPositions,\n      computerPointAttempt,\n      DIRECTIONS.HORIZONTAL\n    );\n    computerPointAttempt.xIndex = x;\n    computerPointAttempt.yIndex = y;\n    if (firstAnalysisResult !== null) {\n      if (firstAnalysisResult.count === 5) {\n        return computerPointAttempt;\n      }\n      addToFirstAnalysisResult(firstAnalysisResult, computerFirstResultMap);\n    }\n\n    firstAnalysisResult = tryAndCalculateResult(\n      computerExistingPositions,\n      humanExistingPositions,\n      computerPointAttempt,\n      DIRECTIONS.VERTICAL\n    );\n    computerPointAttempt.xIndex = x;\n    computerPointAttempt.yIndex = y;\n    if (firstAnalysisResult !== null) {\n      if (firstAnalysisResult.count === 5) {\n        return computerPointAttempt;\n      }\n      addToFirstAnalysisResult(firstAnalysisResult, computerFirstResultMap);\n    }\n\n    firstAnalysisResult = tryAndCalculateResult(\n      computerExistingPositions,\n      humanExistingPositions,\n      computerPointAttempt,\n      DIRECTIONS.DIAGONAL_TOPLEFT_BOTTOMRIGHT\n    );\n    computerPointAttempt.xIndex = x;\n    computerPointAttempt.yIndex = y;\n    if (firstAnalysisResult !== null) {\n      if (firstAnalysisResult.count === 5) {\n        return computerPointAttempt;\n      }\n      addToFirstAnalysisResult(firstAnalysisResult, computerFirstResultMap);\n    }\n\n    firstAnalysisResult = tryAndCalculateResult(\n      computerExistingPositions,\n      humanExistingPositions,\n      computerPointAttempt,\n      DIRECTIONS.DIAGONAL_TOPRIGHT_BOTTOMLEFT\n    );\n    computerPointAttempt.xIndex = x;\n    computerPointAttempt.yIndex = y;\n    if (firstAnalysisResult !== null) {\n      if (firstAnalysisResult.count === 5) {\n        return computerPointAttempt;\n      }\n      addToFirstAnalysisResult(firstAnalysisResult, computerFirstResultMap);\n    }\n\n    // opposite direction of anaylsis, human side\n    firstAnalysisResult = tryAndCalculateResult(\n      humanExistingPositions,\n      computerExistingPositions,\n      computerPointAttempt,\n      DIRECTIONS.HORIZONTAL\n    );\n    computerPointAttempt.xIndex = x;\n    computerPointAttempt.yIndex = y;\n    if (firstAnalysisResult !== null) {\n      if (firstAnalysisResult.count === 5) {\n        humanPointAttempt = computerPointAttempt;\n      }\n      addToFirstAnalysisResult(firstAnalysisResult, humanFirstResultMap);\n    }\n\n    firstAnalysisResult = tryAndCalculateResult(\n      humanExistingPositions,\n      computerExistingPositions,\n      computerPointAttempt,\n      DIRECTIONS.VERTICAL\n    );\n    computerPointAttempt.xIndex = x;\n    computerPointAttempt.yIndex = y;\n    if (firstAnalysisResult !== null) {\n      if (firstAnalysisResult.count === 5) {\n        humanPointAttempt = computerPointAttempt;\n      }\n      addToFirstAnalysisResult(firstAnalysisResult, humanFirstResultMap);\n    }\n\n    firstAnalysisResult = tryAndCalculateResult(\n      humanExistingPositions,\n      computerExistingPositions,\n      computerPointAttempt,\n      DIRECTIONS.DIAGONAL_TOPLEFT_BOTTOMRIGHT\n    );\n    computerPointAttempt.xIndex = x;\n    computerPointAttempt.yIndex = y;\n    if (firstAnalysisResult !== null) {\n      if (firstAnalysisResult.count === 5) {\n        humanPointAttempt = computerPointAttempt;\n      }\n      addToFirstAnalysisResult(firstAnalysisResult, humanFirstResultMap);\n    }\n\n    firstAnalysisResult = tryAndCalculateResult(\n      humanExistingPositions,\n      computerExistingPositions,\n      computerPointAttempt,\n      DIRECTIONS.DIAGONAL_TOPRIGHT_BOTTOMLEFT\n    );\n    computerPointAttempt.xIndex = x;\n    computerPointAttempt.yIndex = y;\n    if (firstAnalysisResult !== null) {\n      if (firstAnalysisResult.count === 5) {\n        humanPointAttempt = computerPointAttempt;\n      }\n      addToFirstAnalysisResult(firstAnalysisResult, humanFirstResultMap);\n    }\n  }\n\n  return humanPointAttempt;\n};\n","/* eslint-disable complexity */\nconst analysisBestPoint = (mySecondAnalysisResults, yourSecondAnalysisResults) => {\n  if (mySecondAnalysisResults.length !== 0) {\n    if (mySecondAnalysisResults.length === 1) {\n      return mySecondAnalysisResults[0].position;\n    }\n    for (let i = 0; i < yourSecondAnalysisResults.length; i += 1) {\n      const yourResult = yourSecondAnalysisResults[i];\n      const commonBestPoint = mySecondAnalysisResults.find(\n        (myResult) =>\n          myResult.position.xIndex === yourResult.position.xIndex &&\n          myResult.position.yIndex === yourResult.position.yIndex\n      );\n      if (commonBestPoint) {\n        return commonBestPoint.position;\n      }\n    }\n    return mySecondAnalysisResults[0].position;\n  }\n\n  return null;\n};\n\nconst getBestPoint = (analysisResults) => {\n  let bestPoint = analysisBestPoint(\n    analysisResults.computerDouble3Alives,\n    analysisResults.humanSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  bestPoint = analysisBestPoint(\n    analysisResults.computer3Alives,\n    analysisResults.humanSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  bestPoint = analysisBestPoint(\n    analysisResults.humanDouble3Alives,\n    analysisResults.computerSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  bestPoint = analysisBestPoint(\n    analysisResults.human3Alives,\n    analysisResults.computerSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  bestPoint = analysisBestPoint(\n    analysisResults.computerDouble2Alives,\n    analysisResults.humanSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  bestPoint = analysisBestPoint(\n    analysisResults.computer2Alives,\n    analysisResults.humanSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  bestPoint = analysisBestPoint(\n    analysisResults.computer3HalfAlives,\n    analysisResults.humanSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  bestPoint = analysisBestPoint(\n    analysisResults.human4HalfAlives,\n    analysisResults.computerSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  bestPoint = analysisBestPoint(\n    analysisResults.humanDouble2Alives,\n    analysisResults.computerSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  bestPoint = analysisBestPoint(\n    analysisResults.human2Alives,\n    analysisResults.computerSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  bestPoint = analysisBestPoint(\n    analysisResults.human3HalfAlives,\n    analysisResults.computerSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  return null;\n};\n\nexport const applyThirdAnalysis = (analysisResults) => {\n  if (analysisResults.computer4HalfAlives.length !== 0) {\n    return analysisResults.computer4HalfAlives[0].position;\n  }\n\n  let bestPoint = analysisBestPoint(\n    analysisResults.human4Alives,\n    analysisResults.computerSecondResults\n  );\n  if (bestPoint) {\n    return bestPoint;\n  }\n\n  bestPoint = getBestPoint(analysisResults);\n  if (bestPoint) {\n    return bestPoint;\n  }\n\n  return analysisResults.computerSecondResults[0].position;\n};\n","/* eslint-disable no-continue */\n/* eslint-disable complexity */\nimport { getFirstPosition } from '../aiLogics/getFirstPosition';\nimport { initialiseAnalysisRange } from '../aiLogics/initialiseAnalysisRange';\nimport { CHESS_TYPES } from '../constants';\nimport { applyFirstAnalysis } from '../aiLogics/applyFirstAnalysis';\nimport { applySecondComputerAnalysis } from '../aiLogics/applySecondComputerAnalysis';\nimport { applySecondHumanAnalysis } from '../aiLogics/applySecondHumanAnalysis';\nimport { applyThirdAnalysis } from '../aiLogics/applyThirdAnalysis';\n\nconst getAllEmptyPoints = (chessMap) => {\n  return chessMap\n    .filter((chess) => chess.chessType === CHESS_TYPES.EMPTY)\n    .map((chess) => ({\n      xIndex: parseInt(chess.xIndex, 10),\n      yIndex: parseInt(chess.yIndex, 10),\n    }));\n};\n\nlet computerFirstResultMap = new Map();\nlet humanFirstResultMap = new Map();\n\nconst analysisResults = {};\n\nconst initAnalysisResult = () => {\n  computerFirstResultMap = new Map();\n  humanFirstResultMap = new Map();\n\n  analysisResults.computerSecondResults = [];\n  analysisResults.humanSecondResults = [];\n\n  analysisResults.computer4HalfAlives = [];\n  analysisResults.computerDouble3Alives = [];\n  analysisResults.computer3Alives = [];\n  analysisResults.computerDouble2Alives = [];\n  analysisResults.computer2Alives = [];\n  analysisResults.computer3HalfAlives = [];\n\n  analysisResults.human4Alives = [];\n  analysisResults.human4HalfAlives = [];\n  analysisResults.humanDouble3Alives = [];\n  analysisResults.human3Alives = [];\n  analysisResults.humanDouble2Alives = [];\n  analysisResults.human2Alives = [];\n  analysisResults.human3HalfAlives = [];\n};\n\nconst startAnalysis = (currentChess, chessOrder, chessMap) => {\n  if (chessOrder.length === 1) {\n    return getFirstPosition(currentChess);\n  }\n\n  // 1. initRange to search\n  const range = initialiseAnalysisRange(chessOrder, chessMap);\n\n  // 2. init analysis result\n  initAnalysisResult();\n\n  const allEmptyPoints = getAllEmptyPoints(chessMap);\n\n  const humanExistingPositions = chessOrder\n    .filter((chess) => chess.chessType === CHESS_TYPES.BLACK)\n    .map((chess) => ({ xIndex: chess.xIndex, yIndex: chess.yIndex }));\n  const computerExistingPositions = chessOrder\n    .filter((chess) => chess.chessType === CHESS_TYPES.WHITE)\n    .map((chess) => ({ xIndex: chess.xIndex, yIndex: chess.yIndex }));\n\n  // 3. start first analysis\n  let bestPoint = applyFirstAnalysis(\n    computerExistingPositions,\n    humanExistingPositions,\n    allEmptyPoints,\n    range,\n    computerFirstResultMap,\n    humanFirstResultMap\n  );\n  if (bestPoint !== null) {\n    console.log('This position is the most crucial, must be taken!');\n    return bestPoint;\n  }\n\n  console.log('analysisResults before second round', analysisResults);\n\n  // 4. start computer second analysis\n  bestPoint = applySecondComputerAnalysis(computerFirstResultMap, analysisResults);\n  if (bestPoint !== null) {\n    console.log('Almost winning, must take this position');\n    return bestPoint;\n  }\n\n  // 5. start human second analysis\n  bestPoint = applySecondHumanAnalysis(humanFirstResultMap, analysisResults);\n  if (bestPoint !== null) {\n    console.log('Almost losing, must take this position');\n    return bestPoint;\n  }\n\n  console.log('analysisResults before third round', analysisResults);\n\n  // 6. start third analysis (final)\n  return applyThirdAnalysis(analysisResults);\n};\n\nexport const applyConditionalAiLogic = (chessOrder, chessMap) => {\n  const parsedChessOrder = chessOrder.map((chess) => ({\n    ...chess,\n    xIndex: parseInt(chess.xIndex, 10),\n    yIndex: parseInt(chess.yIndex, 10),\n  }));\n  const currentChess = parsedChessOrder[parsedChessOrder.length - 1];\n  const aiChessType =\n    currentChess.chessType === CHESS_TYPES.BLACK ? CHESS_TYPES.WHITE : CHESS_TYPES.BLACK;\n\n  const nextPosition = startAnalysis(currentChess, parsedChessOrder, chessMap);\n\n  return {\n    xIndex: `${nextPosition.xIndex}`,\n    yIndex: `${nextPosition.yIndex}`,\n    chessType: aiChessType,\n  };\n};\n","import { BOARD_SIZE } from '../constants';\n\nexport const getFirstPosition = (currentChess) => {\n  if (\n    currentChess.xIndex === BOARD_SIZE.MIN_X ||\n    currentChess.yIndex === BOARD_SIZE.MIN_Y ||\n    currentChess.xIndex === BOARD_SIZE.MAX_X ||\n    currentChess.yIndex === BOARD_SIZE.MAX_Y\n  ) {\n    return {\n      xIndex: `${BOARD_SIZE.MAX_X / 2}`,\n      yIndex: `${BOARD_SIZE.MAX_Y / 2}`,\n    };\n  }\n  const nextX = `${currentChess.xIndex - 1}`;\n  const nextY = `${currentChess.yIndex}`;\n\n  return {\n    xIndex: nextX,\n    yIndex: nextY,\n  };\n};\n","import { BOARD_SIZE } from '../constants';\n\nexport const initialiseAnalysisRange = (chessOrder) => {\n  const ANAYSIS_RANGE = 1;\n  const currentRange = {\n    rangeMinX: 0,\n    rangeMinY: 0,\n    rangeMaxX: 0,\n    rangeMaxY: 0,\n  };\n  currentRange.rangeMinX = chessOrder[0].xIndex - ANAYSIS_RANGE;\n  currentRange.rangeMinY = chessOrder[0].yIndex - ANAYSIS_RANGE;\n  currentRange.rangeMaxX = chessOrder[0].xIndex + ANAYSIS_RANGE;\n  currentRange.rangeMaxY = chessOrder[0].yIndex + ANAYSIS_RANGE;\n\n  chessOrder.forEach((chess) => {\n    if (chess.xIndex - ANAYSIS_RANGE < currentRange.rangeMinX) {\n      currentRange.rangeMinX = chess.xIndex - ANAYSIS_RANGE;\n    }\n    if (chess.yIndex - ANAYSIS_RANGE < currentRange.rangeMinY) {\n      currentRange.rangeMinY = chess.yIndex - ANAYSIS_RANGE;\n    }\n    if (chess.xIndex + ANAYSIS_RANGE > currentRange.rangeMaxX) {\n      currentRange.rangeMaxX = chess.xIndex + ANAYSIS_RANGE;\n    }\n    if (chess.yIndex + ANAYSIS_RANGE > currentRange.rangeMaxY) {\n      currentRange.rangeMaxY = chess.yIndex + ANAYSIS_RANGE;\n    }\n  });\n\n  currentRange.rangeMinX =\n    currentRange.rangeMinX < BOARD_SIZE.MIN_X ? BOARD_SIZE.MIN_X : currentRange.rangeMinX;\n  currentRange.rangeMinY =\n    currentRange.rangeMinY < BOARD_SIZE.MIN_Y ? BOARD_SIZE.MIN_Y : currentRange.rangeMinY;\n  currentRange.rangeMaxX =\n    currentRange.rangeMaxX > BOARD_SIZE.MAX_X ? BOARD_SIZE.MAX_X : currentRange.rangeMaxX;\n  currentRange.rangeMaxY =\n    currentRange.rangeMaxY > BOARD_SIZE.MAX_Y ? BOARD_SIZE.MAX_Y : currentRange.rangeMaxY;\n  return currentRange;\n};\n","/* eslint-disable complexity */\nimport { ALIVE_STATES } from '../constants';\n\n/* eslint-disable no-restricted-syntax */\nexport const applySecondComputerAnalysis = (firstResultMap, analysisResults) => {\n  let secondResultsInstance = null;\n\n  for (const key of firstResultMap.keys()) {\n    secondResultsInstance = {\n      alive4: 0,\n      alive3: 0,\n      halfAlive4: 0,\n      halfAlive3: 0,\n      alive2: 0,\n      position: key,\n    };\n    const firstResults = firstResultMap.get(key);\n\n    for (let i = 0; i < firstResults.length; i += 1) {\n      const result = firstResults[i];\n      if (result.count === 4) {\n        if (result.aliveState === ALIVE_STATES.ALIVE) {\n          return result.point;\n        }\n        secondResultsInstance.alive4 += 1;\n        analysisResults.computer4HalfAlives.push(secondResultsInstance);\n      } else if (result.count === 3) {\n        if (result.aliveState === ALIVE_STATES.ALIVE) {\n          secondResultsInstance.alive3 += 1;\n          if (secondResultsInstance.alive3 === 1) {\n            analysisResults.computer3Alives.push(secondResultsInstance);\n          } else {\n            analysisResults.computerDouble3Alives.push(secondResultsInstance);\n          }\n        } else {\n          secondResultsInstance.halfAlive3 += 1;\n          analysisResults.computer3HalfAlives.push(secondResultsInstance);\n        }\n      } else {\n        secondResultsInstance.alive2 += 1;\n        if (secondResultsInstance.alive2 === 1) {\n          analysisResults.computer2Alives.push(secondResultsInstance);\n        }\n        analysisResults.computerDouble2Alives.push(secondResultsInstance);\n      }\n    }\n\n    analysisResults.computerSecondResults.push(secondResultsInstance);\n  }\n\n  return null;\n};\n","/* eslint-disable complexity */\nimport { ALIVE_STATES } from '../constants';\n\n/* eslint-disable no-restricted-syntax */\nexport const applySecondHumanAnalysis = (firstResultMap, analysisResults) => {\n  let secondResultsInstance = null;\n\n  for (const key of firstResultMap.keys()) {\n    secondResultsInstance = {\n      alive4: 0,\n      alive3: 0,\n      halfAlive4: 0,\n      halfAlive3: 0,\n      alive2: 0,\n      position: key,\n    };\n    const firstResults = firstResultMap.get(key);\n\n    for (let i = 0; i < firstResults.length; i += 1) {\n      const result = firstResults[i];\n      if (result.count === 4) {\n        if (result.aliveState === ALIVE_STATES.ALIVE) {\n          analysisResults.human4Alives.push(secondResultsInstance);\n        } else {\n          secondResultsInstance.halfAlive4 += 1;\n          analysisResults.human4HalfAlives.push(secondResultsInstance);\n        }\n      } else if (result.count === 3) {\n        if (result.aliveState === ALIVE_STATES.ALIVE) {\n          secondResultsInstance.alive3 += 1;\n          if (secondResultsInstance.alive3 === 1) {\n            analysisResults.human3Alives.push(secondResultsInstance);\n          } else {\n            analysisResults.humanDouble3Alives.push(secondResultsInstance);\n          }\n        } else {\n          secondResultsInstance.halfAlive3 += 1;\n          analysisResults.human3HalfAlives.push(secondResultsInstance);\n        }\n      } else {\n        secondResultsInstance.alive2 += 1;\n        if (secondResultsInstance.alive2 === 1) {\n          analysisResults.human2Alives.push(secondResultsInstance);\n        }\n        analysisResults.humanDouble2Alives.push(secondResultsInstance);\n      }\n    }\n\n    analysisResults.humanSecondResults.push(secondResultsInstance);\n  }\n\n  return null;\n};\n","import React, { useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { Chess } from './components';\nimport { ChessBoardContainer } from './chessBoardStyles';\nimport { applyConditionalAiLogic } from '../../utils/functions/applyAiLogic';\nimport { reverseChessTurn } from '../../utils/functions';\n\nconst ChessBoard = ({ chessOrder, chessMap, chessTurn, hasWon, setChessOrder, setChessTurn }) => {\n  useEffect(() => {\n    if (chessOrder.length % 2 === 1 && !hasWon) {\n      const aiChess = applyConditionalAiLogic(chessOrder, chessMap);\n      setChessOrder((prevState) => [...prevState, aiChess]);\n      reverseChessTurn(setChessTurn);\n    }\n  }, [chessOrder, chessMap, setChessOrder, setChessTurn, hasWon]);\n\n  return (\n    <ChessBoardContainer>\n      {chessMap.map((chess) => (\n        <Chess\n          key={`${chess.chessType}-${chess.xIndex}-${chess.yIndex}`}\n          chessType={chess.chessType}\n          chessTurn={chessTurn}\n          xIndex={chess.xIndex}\n          yIndex={chess.yIndex}\n          hasWon={hasWon}\n          setChessOrder={setChessOrder}\n          setChessTurn={setChessTurn}\n        />\n      ))}\n    </ChessBoardContainer>\n  );\n};\n\nChessBoard.propTypes = {\n  chessMap: PropTypes.arrayOf(PropTypes.shape()).isRequired,\n  chessTurn: PropTypes.string.isRequired,\n  hasWon: PropTypes.bool.isRequired,\n  setChessOrder: PropTypes.func.isRequired,\n  setChessTurn: PropTypes.func.isRequired,\n};\n\nexport default ChessBoard;\n","import styled from 'styled-components';\nimport { colors } from '../../utils/styleVars';\n\nconst sizes = {\n  borderWidth: '3px',\n};\n\nexport const DialogContainer = styled.div`\n  align-items: center;\n  border-style: solid;\n  border-color: ${colors.black};\n  border-width: ${sizes.borderWidth};\n  display: flex;\n  flex-direction: column;\n  height: 30vh;\n  justify-content: center;\n  left: 100vh;\n  position: absolute;\n  top: 0;\n  width: calc(100vw - 100vh - 2 * ${sizes.borderWidth});\n`;\n\nexport const VictoryMessage = styled.div`\n  color: ${colors.black};\n  font-size: 1.6rem;\n  font-weight: 300;\n  margin: 1vh;\n  text-align: center;\n`;\n\nexport const ResetButton = styled.button`\n  border-style: none;\n  background-color: ${colors.black};\n  color: ${colors.white};\n  font-size: 1.6rem;\n  padding: 1vh;\n  &:hover {\n    background-color: ${colors.white};\n    color: ${colors.black};\n  }\n`;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { DialogContainer, VictoryMessage, ResetButton } from './dialogStyles';\nimport { reverseChessTurn } from '../../utils/functions';\n\nconst Dialog = ({ chessTypeHasWon, socket, firstTurnColor, setChessOrder, setChessTurn }) => {\n  const handleReset = () => {\n    if (socket) {\n      socket.emit('resetChessMap');\n      return;\n    }\n    setChessOrder([]);\n    setChessTurn(firstTurnColor);\n  };\n\n  const handleUndo = () => {\n    if (socket) {\n      socket.emit('undoChessAction');\n      return;\n    }\n    setChessOrder((prevState) => {\n      prevState.pop();\n      return [...prevState];\n    });\n    reverseChessTurn(setChessTurn);\n  };\n\n  return (\n    <DialogContainer>\n      {chessTypeHasWon && <VictoryMessage>{`${chessTypeHasWon} has won`}</VictoryMessage>}\n      <ResetButton onClick={handleReset}>Reset</ResetButton>\n      <ResetButton onClick={handleUndo}>Undo</ResetButton>\n    </DialogContainer>\n  );\n  // Timer\n};\n\nDialog.propTypes = {\n  chessTypeHasWon: PropTypes.string,\n  firstTurnColor: PropTypes.string.isRequired,\n  setChessOrder: PropTypes.func.isRequired,\n  setChessTurn: PropTypes.func.isRequired,\n};\n\nDialog.defaultProps = {\n  chessTypeHasWon: '',\n};\n\nexport default Dialog;\n","import styled from 'styled-components';\n\nexport const OuterContainer = styled.div`\n  display: flex;\n  justify-content: center;\n  text-align: center;\n  height: 100vh;\n  align-items: center;\n  background-color: #1a1a1d;\n\n  @media (min-width: 320px) and (max-width: 480px) {\n    height: 100%;\n  }\n`;\n\nexport const InnerContainer = styled.div`\n  width: 20%;\n\n  @media (min-width: 320px) and (max-width: 480px) {\n    width: 90%;\n  }\n`;\n\nexport const Input = styled.input`\n  border-radius: 0;\n  padding: 15px 20px;\n  width: 100%;\n  margin-bottom: 20px;\n`;\n\nexport const Heading = styled.h1`\n  color: white;\n  font-size: 2.5em;\n  padding-bottom: 10px;\n  border-bottom: 2px solid white;\n`;\n\nexport const Button = styled.button`\n  color: #fff !important;\n  text-transform: uppercase;\n  text-decoration: none;\n  background: #2979ff;\n  padding: 20px;\n  border-radius: 5px;\n  display: inline-block;\n  border: none;\n  width: 100%;\n  margin-top: 20px;\n\n  :focus {\n    outline: 0;\n  }\n`;\n","import queryString from 'query-string';\nimport { useLocation, BrowserRouter as Router, Route, Routes } from 'react-router-dom';\nimport React, { useEffect, useState } from 'react';\nimport io from 'socket.io-client';\nimport { Chat, MultiChessBoard, Dialog, Entry, SingleChessBoard } from './components';\nimport { CHESS_TYPES } from './utils/constants';\nimport { setEmptyChessMap, updateChessMap, getWinningChessType } from './utils/functions';\n\nconst ENDPOINT = 'http://18.206.247.59:4000';\nlet socket;\n\nconst MultiplayerApp = () => {\n  const location = useLocation();\n  const FIRST_TURN_COLOR = CHESS_TYPES.BLACK;\n  const [chessOrder, setChessOrder] = useState([]);\n  const [chessTurn, setChessTurn] = useState(FIRST_TURN_COLOR);\n  const [name, setName] = useState('');\n  const chessMap = setEmptyChessMap();\n  const chessTypeHasWon = getWinningChessType(chessOrder);\n  updateChessMap(chessOrder, chessMap);\n\n  useEffect(() => {\n    const { name: urlName, room: urlRoom } = queryString.parse(location.search);\n    socket = io(ENDPOINT);\n    setName(urlName);\n    socket.emit('join', { name: urlName, room: urlRoom }, (error) => {\n      if (error) alert(error);\n    });\n  }, [location.search]);\n\n  return (\n    <>\n      <MultiChessBoard\n        firstTurnColor={FIRST_TURN_COLOR}\n        chessMap={chessMap}\n        chessTurn={chessTurn}\n        hasWon={!!chessTypeHasWon}\n        setChessOrder={setChessOrder}\n        setChessTurn={setChessTurn}\n        socket={socket}\n      />\n      <Dialog chessTypeHasWon={chessTypeHasWon} socket={socket} />\n      <Chat name={name} socket={socket} />\n    </>\n  );\n};\n\nconst SingleplayerApp = () => {\n  const FIRST_TURN_COLOR = CHESS_TYPES.BLACK;\n  const [chessOrder, setChessOrder] = useState([]);\n  const [chessTurn, setChessTurn] = useState(FIRST_TURN_COLOR);\n  const chessMap = setEmptyChessMap();\n  const chessTypeHasWon = getWinningChessType(chessOrder);\n  updateChessMap(chessOrder, chessMap);\n\n  return (\n    <>\n      <SingleChessBoard\n        firstTurnColor={FIRST_TURN_COLOR}\n        chessOrder={chessOrder}\n        chessMap={chessMap}\n        chessTurn={chessTurn}\n        hasWon={!!chessTypeHasWon}\n        setChessOrder={setChessOrder}\n        setChessTurn={setChessTurn}\n      />\n      <Dialog\n        chessTypeHasWon={chessTypeHasWon}\n        firstTurnColor={FIRST_TURN_COLOR}\n        setChessOrder={setChessOrder}\n        setChessTurn={setChessTurn}\n      />\n    </>\n  );\n};\n\nconst RouterApp = () => {\n  return (\n    <Router>\n      <Routes>\n        <Route path=\"/entry\" element={<Entry />} />\n        <Route path=\"/game\" element={<MultiplayerApp />} />\n        <Route path=\"/\" element={<SingleplayerApp />} />\n      </Routes>\n    </Router>\n  );\n};\n\nexport default RouterApp;\n","import React, { useState } from 'react';\nimport { Link } from 'react-router-dom';\nimport { Button, Heading, InnerContainer, Input, OuterContainer } from './entryStyles';\n\nconst Entry = () => {\n  const [name, setName] = useState('');\n  const [room, setRoom] = useState('');\n\n  return (\n    <OuterContainer>\n      <InnerContainer>\n        <Heading>Join</Heading>\n        <div>\n          <Input placeholder=\"Name\" type=\"text\" onChange={(event) => setName(event.target.value)} />\n        </div>\n        <div>\n          <Input placeholder=\"Room\" type=\"text\" onChange={(event) => setRoom(event.target.value)} />\n        </div>\n        <Link\n          onClick={(e) => (!name || !room ? e.preventDefault() : null)}\n          to={`/game?name=${name}&room=${room}`}\n        >\n          <Button type=\"submit\">Join</Button>\n        </Link>\n      </InnerContainer>\n    </OuterContainer>\n  );\n};\n\nexport default Entry;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}
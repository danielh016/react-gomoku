{"version":3,"sources":["imgs/Cross.png","components/Chat/chatStyles.js","components/Chat/components/Input/inputStyles.js","components/Chat/components/Input/input.js","components/Chat/components/Messages/Message/messageStyles.js","components/Chat/components/Messages/Message/message.js","components/Chat/components/Messages/messagesStyles.js","components/Chat/components/Messages/messages.js","components/Chat/components/UserTyping/userTyping.js","components/Chat/chat.js","utils/styleVars.js","utils/constants.js","components/MultiChessBoard/components/Chess/chessStyles.js","components/MultiChessBoard/components/Chess/chess.js","components/MultiChessBoard/chessBoardStyles.js","utils/functions/getWinningChessType.js","utils/functions/reverseChessTurn.js","utils/functions/setEmptyChessMap.js","utils/functions/updateChessMap.js","components/MultiChessBoard/chessBoard.js","components/SingleChessBoard/components/Chess/chessStyles.js","components/SingleChessBoard/components/Chess/chess.js","components/SingleChessBoard/chessBoardStyles.js","utils/aiLogics/countPoints.js","utils/aiLogics/getMaxCountOnThisDirection.js","utils/aiLogics/applyFirstAnalysis.js","utils/aiLogics/applyThirdAnalysis.js","utils/functions/applyAiLogic.js","utils/aiLogics/getFirstPosition.js","utils/aiLogics/initialiseAnalysisRange.js","utils/aiLogics/applySecondComputerAnalysis.js","utils/aiLogics/applySecondHumanAnalysis.js","components/SingleChessBoard/chessBoard.js","components/Dialog/dialogStyles.js","components/Dialog/dialog.js","components/Entry/entryStyles.js","App.js","components/Entry/entry.js","serviceWorker.js","index.js"],"names":["module","exports","ChatContainer","styled","div","Form","form","StyledInput","input","SendButton","button","Input","onKeyDown","setMessage","sendMessage","message","type","placeholder","value","onChange","target","onKeyPress","event","key","onClick","e","MessageBox","props","theme","MessageText","p","MessageContainer","start","end","SentText","left","right","Message","text","user","isSentByCurrentUser","trimmedName","name","trim","toLowerCase","MessagesContainer","ScrollToBottom","Messages","messages","map","i","UserTyping","userTyping","isCurrentUser","status","Chat","socket","useState","setMessages","setUserTyping","useEffect","on","newMessage","prevMessages","timeout","handleTypingTimeout","emit","clearTimeout","setTimeout","preventDefault","colors","CHESS_TYPES","DIRECTIONS","ALIVE_STATES","BOARD_SIZE","COUNT_DIRECTION","getFirstTurnColor","isWhite","getDefaultChessOrder","xIndex","yIndex","chessType","ChessContainer","cross","BlackChess","WhiteChess","EmptyGrid","chessTurn","mouseHovered","hasWon","Chess","setMouseHovered","mouseHover","handleChessClicked","onMouseEnter","onMouseLeave","renderChessType","defaultProps","ChessBoardContainer","getChessNextToCurrent","currentChess","chessOrder","direction","chessNextToCurrent","find","otherChess","parseInt","checkHasWonWithDirection","numberOfSameTypeInARow","updatedNumberOfSameTypeInARow","WINNING_CONDITION_NUMBER","reachWinningCondition","getWinningChessType","condition","reverseChessTurn","setChessTurn","prevState","setEmptyChessMap","chessMap","x","y","push","toString","updateChessMap","updatedChessMap","forEach","order","mapElement","ChessBoard","firstTurnColor","setChessOrder","pop","chess","pointToNext","pointAttempt","countDirection","updatedPoint","isOutOfWall","checkIncludes","existingPositions","nextPointAttempt","some","existingPosition","countPoints","myExistingPositions","opponentExistingPositions","firstAnalysisResult","updatedFirstAnalysisResult","count","aliveState","isExistingPoint","existingPoints","existingPoint","updateXIndex","point","updateYIndex","updateXYIndex","xValue","yValue","tryAndCalculateResult","computerPointAttempt","maxCountOnThisDirection","counter","currentX","currentY","getMaxCountOnThisDirection","addToFirstAnalysisResult","firstResultMap","has","get","list","set","analysisBestPoint","mySecondAnalysisResults","yourSecondAnalysisResults","length","position","yourResult","commonBestPoint","myResult","applyThirdAnalysis","analysisResults","computer4HalfAlives","bestPoint","human4Alives","computerSecondResults","computerDouble3Alives","humanSecondResults","computer3Alives","humanDouble3Alives","human3Alives","computerDouble2Alives","computer2Alives","computer3HalfAlives","human4HalfAlives","humanDouble2Alives","human2Alives","human3HalfAlives","getBestPoint","computerFirstResultMap","Map","humanFirstResultMap","startAnalysis","aiChessType","getFirstPosition","range","currentRange","rangeMinX","rangeMinY","rangeMaxX","rangeMaxY","initialiseAnalysisRange","allEmptyPoints","filter","getAllEmptyPoints","humanChessType","humanExistingPositions","computerExistingPositions","humanPointAttempt","applyFirstAnalysis","console","log","secondResultsInstance","keys","alive4","alive3","halfAlive4","halfAlive3","alive2","firstResults","result","applySecondComputerAnalysis","applySecondHumanAnalysis","aiChess","parsedChessOrder","nextPosition","applyConditionalAiLogic","sizes","DialogContainer","VictoryMessage","ResetButton","Dialog","chessTypeHasWon","OuterContainer","InnerContainer","Heading","h1","Button","Entry","setName","room","setRoom","to","MultiplayerApp","location","useLocation","FIRST_TURN_COLOR","queryString","parse","search","urlName","urlRoom","io","error","alert","SingleplayerApp","RouterApp","path","element","exact","Boolean","window","hostname","match","ReactDOM","render","StrictMode","App","document","getElementById","navigator","serviceWorker","ready","then","registration","unregister","catch"],"mappings":"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","file":"static/js/main.037b1fd3.chunk.js","sourcesContent":["module.exports = \"data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFIAAABSCAYAAADHLIObAAADwnRFWHRteGZpbGUAJTNDbXhmaWxlJTIwaG9zdCUzRCUyMmFwcC5kaWFncmFtcy5uZXQlMjIlMjBtb2RpZmllZCUzRCUyMjIwMjAtMDgtMjdUMDElM0EzNiUzQTQ3LjY5MFolMjIlMjBhZ2VudCUzRCUyMjUuMCUyMChNYWNpbnRvc2glM0IlMjBJbnRlbCUyME1hYyUyME9TJTIwWCUyMDEwXzE1XzUpJTIwQXBwbGVXZWJLaXQlMkY1MzcuMzYlMjAoS0hUTUwlMkMlMjBsaWtlJTIwR2Vja28pJTIwQ2hyb21lJTJGODQuMC40MTQ3LjEyNSUyMFNhZmFyaSUyRjUzNy4zNiUyMiUyMGV0YWclM0QlMjJPUWZpQjJPai16S2dRUUVKei1hUSUyMiUyMHZlcnNpb24lM0QlMjIxMy40LjIlMjIlMjB0eXBlJTNEJTIyZ29vZ2xlJTIyJTNFJTNDZGlhZ3JhbSUyMGlkJTNEJTIyWDhRTjZMM3VQYmhVTXZ6NUttUnglMjIlMjBuYW1lJTNEJTIyUGFnZS0xJTIyJTNFM1pSZFQ4SXdGSVolMkZ6UzVOdG5XZ1hncE1UUWlKU295WHBxN0hyYkZyU2VtQThlc3Q5T3lqTEFieDBxdTFUMCUyRmYwJTJGT2VyZ0dabHJzSFRWZkZRakVRUVJ5eVhVQm1RUnhIU1R5Mm53T3BIYmtKaVFPNTVneURPckRrZTBBWUlxMDRnN1VYYUpRU2hxOThtQ2twSVRNZW8xcXJyUiUyRjJxWVNmZFVWekdJQmxSc1dRdm5GbUNxd2l2dTc0SSUyRkM4YURKSDQxdTM4a0d6cjF5clNtSSUyQnFTUzRsWkkyTWxqanVxQk1iWHVJcEFHWmFxV01HNVc3S1lpRHJZMWpidCUyRjlENnZ0a1RWSTg1c044M1NldlU3MnolMkZGN05XTXBwYU9GZkxsQ2xRMFZGVnFCaHpWMTR3MUlkbmV3Mk02TzFaRkpZVXBoWjVFZHVtaGdBM3U3VTBWdHJmYjZnQ3JCNk5xR2JEdWZSJTJCaFEwYk80WVJvRU5Yemp5MU5zZDk3S3RSbWVGTGVKNHhDdlpoS2lEbDdNSkFsOWliV3FkQWE0cSUyQiUyRmVHU0V5UGhFeVZPZGdCa0oyMEN1N1E4Zm1YTkFvOHM4YjFmcFpuJTJGaDljYU9TTTBKJTJGYnBTZGRuJTJCckMlMkI5ZVE1SiUyQkF3JTNEJTNEJTNDJTJGZGlhZ3JhbSUzRSUzQyUyRm14ZmlsZSUzRYZp158AAAE0SURBVHhe7d1BCsJAEEXBzsnVkyuDV6hFh7yA28dY+dsh1+x/3jNzfqufa/Xp/of7zsz6c64/YJBu6i0SWQYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRYZJBJAmRb5NMhzh+WF/vQTM59zD6jrIejVBxkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZFhkkEkCZOyyy79mgl32LzA8BqVJT/CwcjQAAAABJRU5ErkJggg==\"","import styled from 'styled-components';\n\nconst sizes = {\n  borderWidth: '3px',\n};\n\nexport const ChatContainer = styled.div`\n  display: flex;\n  flex-direction: column;\n  height: 70vh;\n  left: 100vh;\n\n  position: absolute;\n  top: 30vh;\n  width: calc(100vw - 100vh - 2 * ${sizes.borderWidth});\n`;\n","import styled from 'styled-components';\n\nexport const Form = styled.form`\n  display: flex;\n  border-top: 2px solid #d3d3d3;\n`;\n\nexport const StyledInput = styled.input`\n  border: none;\n  border-radius: 0;\n  padding: 2%;\n  width: 80%;\n  font-size: 1.2em;\n\n  :focus {\n    outline: none;\n  }\n`;\n\nexport const SendButton = styled.button`\n  color: #fff !important;\n  cursor: pointer;\n  text-transform: uppercase;\n  text-decoration: none;\n  background: green;\n  padding: 10px;\n  display: inline-block;\n  border: none;\n  width: 20%;\n\n  :hover {\n    opacity: 0.8;\n  }\n`;\n","import React from 'react';\nimport { Form, SendButton, StyledInput } from './inputStyles';\n\n// TODO: use formik here\nconst Input = ({ onKeyDown, setMessage, sendMessage, message }) => (\n  <Form>\n    <StyledInput\n      type=\"text\"\n      placeholder=\"Type a message...\"\n      value={message}\n      onChange={({ target: { value } }) => setMessage(value)}\n      onKeyDown={onKeyDown}\n      onKeyPress={(event) => (event.key === 'Enter' ? sendMessage(event) : null)}\n    />\n    <SendButton onClick={(e) => sendMessage(e)}>Send</SendButton>\n  </Form>\n);\n\nexport default Input;\n","import styled from 'styled-components';\n\nexport const MessageBox = styled.div`\n  background: ${(props) => {\n    if (props.theme === 'dark') return '#2979FF';\n    if (props.theme === 'light') return '#F3F3F3';\n    return '#F3F3F3';\n  }};\n  border-radius: 20px;\n  padding: 5px 20px;\n  color: white;\n  display: inline-block;\n  max-width: 80%;\n`;\n\nexport const MessageText = styled.p`\n  color: ${(props) => {\n    if (props.theme === 'dark') return 'white';\n    if (props.theme === 'light') return '#353535';\n    return '#353535';\n  }};\n  width: 100%;\n  letter-spacing: 0;\n  float: left;\n  font-size: 1.1em;\n  word-wrap: break-word;\n\n  img {\n    vertical-align: middle;\n  }\n`;\n\nexport const MessageContainer = styled.div`\n  display: flex;\n  justify-content: ${(props) => {\n    if (props.start) return 'flex-start';\n    if (props.end) return 'flex-end';\n    return 'flex-end';\n  }};\n  padding: 0 5%;\n  margin-top: 3px;\n`;\n\nexport const SentText = styled.p`\n  display: flex;\n  align-items: center;\n  font-family: Helvetica;\n  color: #828282;\n  letter-spacing: 0.3px;\n\n  padding-left: ${(props) => (props.left ? '10px' : '0')};\n  padding-right: ${(props) => (props.right ? '10px' : '0')};\n`;\n","/* eslint-disable react/prop-types */\nimport React from 'react';\nimport { MessageBox, MessageContainer, MessageText, SentText } from './messageStyles';\n\nconst Message = ({ message: { text, user }, name }) => {\n  let isSentByCurrentUser = false;\n\n  const trimmedName = name.trim().toLowerCase();\n\n  if (user === trimmedName) {\n    isSentByCurrentUser = true;\n  }\n\n  return isSentByCurrentUser ? (\n    <MessageContainer end>\n      <SentText right>{trimmedName}</SentText>\n      <MessageBox theme=\"dark\">\n        <MessageText theme=\"dark\">{text}</MessageText>\n      </MessageBox>\n    </MessageContainer>\n  ) : (\n    <MessageContainer start>\n      <MessageBox theme=\"light\">\n        <MessageText theme=\"light\">{text}</MessageText>\n      </MessageBox>\n      <SentText left>{user}</SentText>\n    </MessageContainer>\n  );\n};\n\nexport default Message;\n","import ScrollToBottom from 'react-scroll-to-bottom';\nimport styled from 'styled-components';\n\nexport const MessagesContainer = styled(ScrollToBottom)`\n  padding: 5% 0;\n  overflow: auto;\n  flex: auto;\n`;\n","import React from 'react';\nimport Message from './Message';\nimport { MessagesContainer } from './messagesStyles';\n\nconst Messages = ({ messages, name }) => (\n  <MessagesContainer>\n    {messages.map((message, i) => (\n      <div key={i}>\n        <Message message={message} name={name} />\n      </div>\n    ))}\n  </MessagesContainer>\n);\n\nexport default Messages;\n","/* eslint-disable react/prop-types */\nimport React from 'react';\n\nconst UserTyping = ({ userTyping, name }) => {\n  const trimmedName = name.trim().toLowerCase();\n  let isCurrentUser = false;\n\n  if (userTyping.user === trimmedName) {\n    isCurrentUser = true;\n  }\n\n  if (userTyping.status && !isCurrentUser) {\n    return <>{userTyping.user} is typing...</>;\n  }\n  return <></>;\n};\n\nexport default UserTyping;\n","import React, { useEffect, useState } from 'react';\nimport { ChatContainer } from './chatStyles';\nimport Input from './components/Input';\nimport Messages from './components/Messages';\nimport UserTyping from './components/UserTyping';\n\nconst Chat = ({ name, socket }) => {\n  const [message, setMessage] = useState('');\n  const [messages, setMessages] = useState([]);\n  const [userTyping, setUserTyping] = useState({});\n\n  useEffect(() => {\n    if (socket) {\n      socket.on('message', (newMessage) => {\n        setMessages((prevMessages) => [...prevMessages, newMessage]);\n      });\n      socket.on('typing', ({ user, status }) => {\n        setUserTyping({ user, status });\n      });\n    }\n  }, [socket]);\n\n  const sendMessage = (event) => {\n    event.preventDefault();\n\n    if (message) {\n      socket.emit('sendMessage', message, () => setMessage(''));\n    }\n  };\n\n  let timeout;\n\n  const handleTypingTimeout = () => {\n    socket.emit('typing', { status: false });\n  };\n\n  const handleKeyDown = () => {\n    socket.emit('typing', { status: true });\n    clearTimeout(timeout);\n    timeout = setTimeout(handleTypingTimeout, 5000);\n  };\n\n  return (\n    <ChatContainer>\n      <Messages messages={messages} name={name} />\n      <UserTyping userTyping={userTyping} name={name} />\n      <Input\n        message={message}\n        onKeyDown={handleKeyDown}\n        setMessage={setMessage}\n        sendMessage={sendMessage}\n      />\n    </ChatContainer>\n  );\n};\n\nexport default Chat;\n","// eslint-disable-next-line import/prefer-default-export\nexport const colors = {\n  chessboardBrown: '#A5682A',\n  black: '#000000',\n  red: '#C73B0F',\n  white: '#ffffff',\n};\n","export const CHESS_TYPES = {\n  BLACK: 'BLACK',\n  WHITE: 'WHITE',\n  EMPTY: 'EMPTY',\n};\n\nexport const DIRECTIONS = {\n  HORIZONTAL: 'HORIZONTAL',\n  VERTICAL: 'VERTICAL',\n  DIAGONAL_TOPLEFT_BOTTOMRIGHT: 'DIAGONAL_TOPLEFT_BOTTOMRIGHT',\n  DIAGONAL_TOPRIGHT_BOTTOMLEFT: 'DIAGONAL_TOPRIGHT_BOTTOMLEFT',\n};\n\nexport const ALIVE_STATES = {\n  ALIVE: 'ALIVE',\n  HALF_ALIVE: 'HALF_ALIVE',\n};\n\nexport const BOARD_SIZE = {\n  MIN_X: 0,\n  MIN_Y: 0,\n  MAX_X: 14,\n  MAX_Y: 14,\n};\n\nexport const COUNT_DIRECTION = {\n  FORWARD: 'FORWARD',\n  BACKWARD: 'BACKWARD',\n};\n\nexport const getFirstTurnColor = (isWhite) => {\n  return isWhite ? CHESS_TYPES.WHITE : CHESS_TYPES.BLACK;\n};\n\nexport const getDefaultChessOrder = (isWhite) => {\n  return isWhite ? [{ xIndex: '7', yIndex: '7', chessType: CHESS_TYPES.BLACK }] : [];\n};\n","import styled from 'styled-components';\nimport { colors } from '../../../../utils/styleVars';\nimport { CHESS_TYPES } from '../../../../utils/constants';\nimport cross from '../../../../imgs/Cross.png';\n\nexport const ChessContainer = styled.div`\n  align-items: center;\n  background-image: url(${cross});\n  background-position: center;\n  display: flex;\n  height: calc(100vh / 15);\n  justify-content: center;\n  left: calc(100vh / 15 * ${(props) => props.xIndex});\n  position: absolute;\n  top: calc(100vh / 15 * ${(props) => props.yIndex});\n  width: calc(100vh / 15);\n  z-index: 1;\n`;\n\nexport const BlackChess = styled.div`\n  background-color: ${colors.black};\n  border-radius: 100%;\n  height: 70%;\n  width: 70%;\n`;\n\nexport const WhiteChess = styled.div`\n  background-color: ${colors.white};\n  border-radius: 100%;\n  height: 70%;\n  width: 70%;\n`;\n\nexport const EmptyGrid = styled.div`\n  border-color: ${(props) => (props.chessTurn === CHESS_TYPES.BLACK ? colors.black : colors.white)};\n  border-style: ${(props) => (props.mouseHovered && !props.hasWon ? 'solid' : 'none')};\n  height: 100%;\n  width: 100%;\n`;\n","import React, { useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { ChessContainer, BlackChess, WhiteChess, EmptyGrid } from './chessStyles';\nimport { CHESS_TYPES } from '../../../../utils/constants';\n\nconst Chess = ({ chessType, chessTurn, xIndex, yIndex, hasWon, socket }) => {\n  const [mouseHovered, setMouseHovered] = useState(false);\n\n  const mouseHover = () => {\n    setMouseHovered(!mouseHovered);\n  };\n\n  const handleChessClicked = () => {\n    socket.emit('addChessOrder', { xIndex, yIndex, chessType: chessTurn });\n  };\n\n  const renderChessType = (type) => {\n    switch (type) {\n      case CHESS_TYPES.BLACK:\n        return <BlackChess />;\n      case CHESS_TYPES.WHITE:\n        return <WhiteChess />;\n      case CHESS_TYPES.EMPTY:\n        return (\n          <EmptyGrid\n            onMouseEnter={mouseHover}\n            onMouseLeave={mouseHover}\n            mouseHovered={mouseHovered}\n            hasWon={hasWon}\n            chessTurn={chessTurn}\n            onClick={hasWon ? () => {} : handleChessClicked}\n          />\n        );\n      default:\n        return <EmptyGrid />;\n    }\n  };\n\n  return (\n    <ChessContainer xIndex={xIndex} yIndex={yIndex}>\n      {renderChessType(chessType)}\n    </ChessContainer>\n  );\n};\n\nChess.propTypes = {\n  chessType: PropTypes.string,\n  chessTurn: PropTypes.string.isRequired,\n  xIndex: PropTypes.string.isRequired,\n  yIndex: PropTypes.string.isRequired,\n  hasWon: PropTypes.bool.isRequired,\n};\n\nChess.defaultProps = {\n  chessType: 'empty',\n};\n\nexport default Chess;\n","import styled from 'styled-components';\nimport { colors } from '../../utils/styleVars';\n\n// eslint-disable-next-line import/prefer-default-export\nexport const ChessBoardContainer = styled.div`\n  background-color: ${colors.chessboardBrown};\n  height: 100vh;\n  left: 0\n  position: absolute;\n  top: 0;\n  width: 100vh;\n  z-index: 0;\n`;\n","import { DIRECTIONS } from '../constants';\n\nconst getChessNextToCurrent = (currentChess, chessOrder, direction) => {\n  let chessNextToCurrent = null;\n\n  switch (direction) {\n    case DIRECTIONS.HORIZONTAL: {\n      chessNextToCurrent = chessOrder.find(\n        (otherChess) =>\n          parseInt(otherChess.xIndex, 10) === parseInt(currentChess.xIndex, 10) + 1 &&\n          parseInt(otherChess.yIndex, 10) === parseInt(currentChess.yIndex, 10)\n      );\n      break;\n    }\n    case DIRECTIONS.VERTICAL: {\n      chessNextToCurrent = chessOrder.find(\n        (otherChess) =>\n          parseInt(otherChess.xIndex, 10) === parseInt(currentChess.xIndex, 10) &&\n          parseInt(otherChess.yIndex, 10) === parseInt(currentChess.yIndex, 10) + 1\n      );\n      break;\n    }\n    case DIRECTIONS.DIAGONAL_TOPLEFT_BOTTOMRIGHT: {\n      chessNextToCurrent = chessOrder.find(\n        (otherChess) =>\n          parseInt(otherChess.xIndex, 10) === parseInt(currentChess.xIndex, 10) + 1 &&\n          parseInt(otherChess.yIndex, 10) === parseInt(currentChess.yIndex, 10) + 1\n      );\n      break;\n    }\n    case DIRECTIONS.DIAGONAL_TOPRIGHT_BOTTOMLEFT: {\n      chessNextToCurrent = chessOrder.find(\n        (otherChess) =>\n          parseInt(otherChess.xIndex, 10) === parseInt(currentChess.xIndex, 10) + 1 &&\n          parseInt(otherChess.yIndex, 10) === parseInt(currentChess.yIndex, 10) - 1\n      );\n      break;\n    }\n    default:\n  }\n\n  return chessNextToCurrent;\n};\n\nconst checkHasWonWithDirection = (\n  currentChess,\n  chessOrder,\n  direction,\n  numberOfSameTypeInARow = 1\n) => {\n  let updatedNumberOfSameTypeInARow = numberOfSameTypeInARow;\n\n  const chessNextToCurrent = getChessNextToCurrent(currentChess, chessOrder, direction);\n\n  if (!chessNextToCurrent) return false;\n\n  const WINNING_CONDITION_NUMBER = 5;\n\n  if (chessNextToCurrent.chessType === currentChess.chessType) {\n    updatedNumberOfSameTypeInARow += 1;\n    const reachWinningCondition = updatedNumberOfSameTypeInARow === WINNING_CONDITION_NUMBER;\n\n    if (reachWinningCondition) return true;\n    return checkHasWonWithDirection(\n      chessNextToCurrent,\n      chessOrder,\n      direction,\n      updatedNumberOfSameTypeInARow\n    );\n  }\n\n  return false;\n};\n\nconst getWinningChessType = (chessOrder) => {\n  const hasWonConditionList = chessOrder.map((currentChess) => {\n    const hasWon =\n      checkHasWonWithDirection(currentChess, chessOrder, DIRECTIONS.HORIZONTAL) ||\n      checkHasWonWithDirection(currentChess, chessOrder, DIRECTIONS.VERTICAL) ||\n      checkHasWonWithDirection(currentChess, chessOrder, DIRECTIONS.DIAGONAL_TOPLEFT_BOTTOMRIGHT) ||\n      checkHasWonWithDirection(currentChess, chessOrder, DIRECTIONS.DIAGONAL_TOPRIGHT_BOTTOMLEFT);\n    if (hasWon) {\n      return currentChess.chessType;\n    }\n    return null;\n  });\n\n  const chessTypeHasWon = hasWonConditionList.find((condition) => condition !== null);\n  return chessTypeHasWon;\n};\n\nexport default getWinningChessType;\n","import { CHESS_TYPES } from '../constants';\n\nconst reverseChessTurn = (setChessTurn) => {\n  setChessTurn((prevState) => {\n    if (prevState === CHESS_TYPES.BLACK) {\n      setChessTurn(CHESS_TYPES.WHITE);\n    }\n    if (prevState === CHESS_TYPES.WHITE) {\n      setChessTurn(CHESS_TYPES.BLACK);\n    }\n  });\n};\n\nexport default reverseChessTurn;\n","import { CHESS_TYPES } from '../constants';\n\nconst setEmptyChessMap = () => {\n  const chessMap = [];\n  for (let x = 0; x < 15; x += 1) {\n    for (let y = 0; y < 15; y += 1) {\n      chessMap.push({\n        xIndex: x.toString(),\n        yIndex: y.toString(),\n        chessType: CHESS_TYPES.EMPTY,\n      });\n    }\n  }\n  return chessMap;\n};\n\nexport default setEmptyChessMap;\n","const updateChessMap = (chessOrder, chessMap) => {\n  const updatedChessMap = chessMap;\n  chessOrder.forEach((order) => {\n    updatedChessMap.forEach((mapElement) => {\n      if (order.xIndex === mapElement.xIndex && order.yIndex === mapElement.yIndex) {\n        // eslint-disable-next-line no-param-reassign\n        mapElement.chessType = order.chessType;\n      }\n    });\n  });\n};\n\nexport default updateChessMap;\n","import React, { useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { Chess } from './components';\nimport { ChessBoardContainer } from './chessBoardStyles';\nimport { reverseChessTurn } from '../../utils/functions';\n\nconst ChessBoard = ({\n  firstTurnColor,\n  chessMap,\n  chessTurn,\n  hasWon,\n  setChessOrder,\n  setChessTurn,\n  socket,\n}) => {\n  useEffect(() => {\n    if (socket) {\n      socket.on('updateChessOrder', ({ xIndex, yIndex, chessType }) => {\n        setChessOrder((prevState) => [\n          ...prevState,\n          { xIndex: `${xIndex}`, yIndex: `${yIndex}`, chessType },\n        ]);\n        reverseChessTurn(setChessTurn);\n      });\n\n      socket.on('resetChessMap', () => {\n        setChessOrder([]);\n        setChessTurn(firstTurnColor);\n      });\n\n      socket.on('undoChessAction', () => {\n        setChessOrder((prevState) => {\n          prevState.pop();\n          return [...prevState];\n        });\n        reverseChessTurn(setChessTurn);\n      });\n    }\n  }, [socket, firstTurnColor, setChessOrder, setChessTurn]);\n\n  return (\n    <ChessBoardContainer>\n      {chessMap.map((chess) => (\n        <Chess\n          key={`${chess.chessType}-${chess.xIndex}-${chess.yIndex}`}\n          chessType={chess.chessType}\n          chessTurn={chessTurn}\n          xIndex={chess.xIndex}\n          yIndex={chess.yIndex}\n          hasWon={hasWon}\n          socket={socket}\n        />\n      ))}\n    </ChessBoardContainer>\n  );\n};\n\nChessBoard.propTypes = {\n  chessMap: PropTypes.arrayOf(PropTypes.shape()).isRequired,\n  chessTurn: PropTypes.string.isRequired,\n  hasWon: PropTypes.bool.isRequired,\n  setChessOrder: PropTypes.func.isRequired,\n  setChessTurn: PropTypes.func.isRequired,\n};\n\nexport default ChessBoard;\n","import styled from 'styled-components';\nimport { colors } from '../../../../utils/styleVars';\nimport { CHESS_TYPES } from '../../../../utils/constants';\nimport cross from '../../../../imgs/Cross.png';\n\nexport const ChessContainer = styled.div`\n  align-items: center;\n  background-image: url(${cross});\n  background-position: center;\n  display: flex;\n  height: calc(100vh / 15);\n  justify-content: center;\n  left: calc(100vh / 15 * ${(props) => props.xIndex});\n  position: absolute;\n  top: calc(100vh / 15 * ${(props) => props.yIndex});\n  width: calc(100vh / 15);\n  z-index: 1;\n`;\n\nexport const BlackChess = styled.div`\n  background-color: ${colors.black};\n  border-radius: 100%;\n  height: 70%;\n  width: 70%;\n`;\n\nexport const WhiteChess = styled.div`\n  background-color: ${colors.white};\n  border-radius: 100%;\n  height: 70%;\n  width: 70%;\n`;\n\nexport const EmptyGrid = styled.div`\n  border-color: ${(props) => (props.chessTurn === CHESS_TYPES.BLACK ? colors.black : colors.white)};\n  border-style: ${(props) => (props.mouseHovered && !props.hasWon ? 'solid' : 'none')};\n  height: 100%;\n  width: 100%;\n`;\n","import React, { useState } from 'react';\nimport PropTypes from 'prop-types';\nimport { ChessContainer, BlackChess, WhiteChess, EmptyGrid } from './chessStyles';\nimport { CHESS_TYPES } from '../../../../utils/constants';\nimport { reverseChessTurn } from '../../../../utils/functions';\n\nconst Chess = ({ chessType, chessTurn, xIndex, yIndex, hasWon, setChessOrder, setChessTurn }) => {\n  const [mouseHovered, setMouseHovered] = useState(false);\n\n  const mouseHover = () => {\n    setMouseHovered(!mouseHovered);\n  };\n\n  const handleChessClicked = () => {\n    setChessOrder((prevState) => [\n      ...prevState,\n      { xIndex: `${xIndex}`, yIndex: `${yIndex}`, chessType: chessTurn },\n    ]);\n    reverseChessTurn(setChessTurn);\n  };\n\n  const renderChessType = (type) => {\n    switch (type) {\n      case CHESS_TYPES.BLACK:\n        return <BlackChess />;\n      case CHESS_TYPES.WHITE:\n        return <WhiteChess />;\n      case CHESS_TYPES.EMPTY:\n        return (\n          <EmptyGrid\n            onMouseEnter={mouseHover}\n            onMouseLeave={mouseHover}\n            mouseHovered={mouseHovered}\n            hasWon={hasWon}\n            chessTurn={chessTurn}\n            onClick={hasWon ? () => {} : handleChessClicked}\n          />\n        );\n      default:\n        return <EmptyGrid />;\n    }\n  };\n\n  return (\n    <ChessContainer xIndex={xIndex} yIndex={yIndex}>\n      {renderChessType(chessType)}\n    </ChessContainer>\n  );\n};\n\nChess.propTypes = {\n  chessType: PropTypes.string,\n  chessTurn: PropTypes.string.isRequired,\n  xIndex: PropTypes.string.isRequired,\n  yIndex: PropTypes.string.isRequired,\n  hasWon: PropTypes.bool.isRequired,\n  setChessOrder: PropTypes.func.isRequired,\n  setChessTurn: PropTypes.func.isRequired,\n};\n\nChess.defaultProps = {\n  chessType: 'empty',\n};\n\nexport default Chess;\n","import styled from 'styled-components';\nimport { colors } from '../../utils/styleVars';\n\n// eslint-disable-next-line import/prefer-default-export\nexport const ChessBoardContainer = styled.div`\n  background-color: ${colors.chessboardBrown};\n  height: 100vh;\n  left: 0;\n  position: absolute;\n  top: 0;\n  width: 100vh;\n  z-index: 0;\n`;\n","import { ALIVE_STATES, BOARD_SIZE, COUNT_DIRECTION, DIRECTIONS } from '../constants';\n\n/* eslint-disable complexity */\nconst pointToNext = (pointAttempt, direction, countDirection) => {\n  const updatedPoint = { ...pointAttempt };\n  switch (direction) {\n    case DIRECTIONS.HORIZONTAL: {\n      if (countDirection === COUNT_DIRECTION.FORWARD) {\n        updatedPoint.xIndex += 1;\n      } else {\n        updatedPoint.xIndex -= 1;\n      }\n      return updatedPoint;\n    }\n    case DIRECTIONS.VERTICAL: {\n      if (countDirection === COUNT_DIRECTION.FORWARD) {\n        updatedPoint.yIndex += 1;\n      } else {\n        updatedPoint.yIndex -= 1;\n      }\n      return updatedPoint;\n    }\n    case DIRECTIONS.DIAGONAL_TOPLEFT_BOTTOMRIGHT: {\n      if (countDirection === COUNT_DIRECTION.FORWARD) {\n        updatedPoint.xIndex += 1;\n        updatedPoint.yIndex += 1;\n      } else {\n        updatedPoint.xIndex -= 1;\n        updatedPoint.yIndex -= 1;\n      }\n      return updatedPoint;\n    }\n    case DIRECTIONS.DIAGONAL_TOPRIGHT_BOTTOMLEFT: {\n      if (countDirection === COUNT_DIRECTION.FORWARD) {\n        updatedPoint.xIndex += 1;\n        updatedPoint.yIndex -= 1;\n      } else {\n        updatedPoint.xIndex -= 1;\n        updatedPoint.yIndex += 1;\n      }\n      return updatedPoint;\n    }\n    default: {\n      break;\n    }\n  }\n\n  return updatedPoint;\n};\n\nconst isOutOfWall = (pointAttempt, direction) => {\n  if (direction === DIRECTIONS.VERTICAL) {\n    return pointAttempt.yIndex < BOARD_SIZE.MIN_Y || pointAttempt.yIndex >= BOARD_SIZE.MAX_Y;\n  }\n  if (direction === DIRECTIONS.HORIZONTAL) {\n    return pointAttempt.xIndex < BOARD_SIZE.MIN_X || pointAttempt.xIndex >= BOARD_SIZE.MAX_X;\n  }\n  return (\n    pointAttempt.xIndex < BOARD_SIZE.MIN_X ||\n    pointAttempt.xIndex >= BOARD_SIZE.MAX_X ||\n    pointAttempt.yIndex < BOARD_SIZE.MIN_Y ||\n    pointAttempt.yIndex >= BOARD_SIZE.MAX_Y\n  );\n};\n\nconst checkIncludes = (existingPositions, nextPointAttempt) => {\n  return existingPositions.some(\n    (existingPosition) =>\n      existingPosition.xIndex === nextPointAttempt.xIndex &&\n      existingPosition.yIndex === nextPointAttempt.yIndex\n  );\n};\n\nexport const countPoints = (\n  myExistingPositions,\n  opponentExistingPositions,\n  pointAttempt,\n  firstAnalysisResult,\n  direction,\n  countDirection\n) => {\n  const updatedFirstAnalysisResult = firstAnalysisResult;\n  let nextPointAttempt = pointToNext(pointAttempt, direction, countDirection);\n\n  if (checkIncludes(myExistingPositions, nextPointAttempt)) {\n    updatedFirstAnalysisResult.count += 1;\n    nextPointAttempt = pointToNext(nextPointAttempt, direction, countDirection);\n\n    if (checkIncludes(myExistingPositions, nextPointAttempt)) {\n      updatedFirstAnalysisResult.count += 1;\n      nextPointAttempt = pointToNext(nextPointAttempt, direction, countDirection);\n\n      if (checkIncludes(myExistingPositions, nextPointAttempt)) {\n        updatedFirstAnalysisResult.count += 1;\n        nextPointAttempt = pointToNext(nextPointAttempt, direction, countDirection);\n\n        if (checkIncludes(myExistingPositions, nextPointAttempt)) {\n          updatedFirstAnalysisResult.count += 1;\n          nextPointAttempt = pointToNext(nextPointAttempt, direction, countDirection);\n        } else if (\n          checkIncludes(opponentExistingPositions, nextPointAttempt) ||\n          isOutOfWall(nextPointAttempt, direction)\n        ) {\n          updatedFirstAnalysisResult.aliveState = ALIVE_STATES.HALF_ALIVE;\n        }\n      } else if (\n        checkIncludes(opponentExistingPositions, nextPointAttempt) ||\n        isOutOfWall(nextPointAttempt, direction)\n      ) {\n        updatedFirstAnalysisResult.aliveState = ALIVE_STATES.HALF_ALIVE;\n      }\n    } else if (\n      checkIncludes(opponentExistingPositions, nextPointAttempt) ||\n      isOutOfWall(nextPointAttempt, direction)\n    ) {\n      updatedFirstAnalysisResult.aliveState = ALIVE_STATES.HALF_ALIVE;\n    }\n  } else if (\n    checkIncludes(opponentExistingPositions, nextPointAttempt) ||\n    isOutOfWall(nextPointAttempt, direction)\n  ) {\n    updatedFirstAnalysisResult.aliveState = ALIVE_STATES.HALF_ALIVE;\n  }\n\n  return updatedFirstAnalysisResult;\n};\n","/* eslint-disable complexity */\n\nimport { BOARD_SIZE, DIRECTIONS } from '../constants';\n\nfunction isExistingPoint(pointAttempt, existingPoints) {\n  return existingPoints.some(\n    (existingPoint) =>\n      existingPoint.xIndex === pointAttempt.xIndex && existingPoint.yIndex === pointAttempt.yIndex\n  );\n}\n\nfunction updateXIndex(point, value) {\n  return { ...point, xIndex: value };\n}\n\nfunction updateYIndex(point, value) {\n  return { ...point, yIndex: value };\n}\n\nfunction updateXYIndex(point, xValue, yValue) {\n  return { ...point, xIndex: xValue, yIndex: yValue };\n}\n\nexport const getMaxCountOnThisDirection = (pointAttempt, existingPositions, direction, count) => {\n  let counter = count;\n  const x = pointAttempt.xIndex;\n  const y = pointAttempt.yIndex;\n\n  let currentX = pointAttempt.xIndex;\n  let currentY = pointAttempt.yIndex;\n\n  switch (direction) {\n    case DIRECTIONS.HORIZONTAL: {\n      while (\n        currentX >= 0 &&\n        !isExistingPoint(updateXIndex(pointAttempt, currentX - 1), existingPositions)\n      ) {\n        counter += 1;\n        currentX -= 1;\n      }\n      currentX = x;\n      while (\n        currentX <= BOARD_SIZE.MAX_X &&\n        !isExistingPoint(updateXIndex(pointAttempt, currentX + 1), existingPositions) &&\n        counter < 6\n      ) {\n        counter += 1;\n        currentX += 1;\n      }\n\n      break;\n    }\n    case DIRECTIONS.VERTICAL: {\n      while (\n        currentY >= 0 &&\n        !isExistingPoint(updateYIndex(pointAttempt, currentY - 1), existingPositions)\n      ) {\n        counter += 1;\n        currentY -= 1;\n      }\n      currentY = x;\n      while (\n        currentY <= BOARD_SIZE.MAX_Y &&\n        !isExistingPoint(updateYIndex(pointAttempt, currentY + 1), existingPositions) &&\n        counter < 6\n      ) {\n        counter += 1;\n        currentY += 1;\n      }\n\n      break;\n    }\n    case DIRECTIONS.DIAGONAL_TOPLEFT_BOTTOMRIGHT: {\n      while (\n        currentX >= 0 &&\n        currentY >= 0 &&\n        !isExistingPoint(updateXYIndex(pointAttempt, currentX - 1, currentY - 1), existingPositions)\n      ) {\n        counter += 1;\n        currentX -= 1;\n        currentY -= 1;\n      }\n      currentX = x;\n      currentY = y;\n      while (\n        currentX < BOARD_SIZE.MAX_X &&\n        currentY < BOARD_SIZE.MAX_Y &&\n        !isExistingPoint(\n          updateXYIndex(pointAttempt, currentX + 1, currentY + 1),\n          existingPositions\n        ) &&\n        counter < 6\n      ) {\n        counter += 1;\n        currentX += 1;\n        currentY += 1;\n      }\n      break;\n    }\n    case DIRECTIONS.DIAGONAL_TOPRIGHT_BOTTOMLEFT: {\n      while (\n        currentX >= 0 &&\n        currentY < BOARD_SIZE.MAX_Y &&\n        !isExistingPoint(updateXYIndex(pointAttempt, currentX - 1, currentY + 1), existingPositions)\n      ) {\n        counter += 1;\n        currentX -= 1;\n        currentY += 1;\n      }\n      currentX = x;\n      currentY = y;\n      while (\n        currentX < BOARD_SIZE.MAX_X &&\n        currentY >= 0 &&\n        !isExistingPoint(\n          updateXYIndex(pointAttempt, currentX + 1, currentY - 1),\n          existingPositions\n        ) &&\n        counter < 6\n      ) {\n        counter += 1;\n        currentX += 1;\n        currentY -= 1;\n      }\n      break;\n    }\n    default: {\n      break;\n    }\n  }\n\n  return counter;\n};\n","/* eslint-disable no-continue */\n/* eslint-disable complexity */\n\nimport { ALIVE_STATES, COUNT_DIRECTION, DIRECTIONS } from '../constants';\nimport { countPoints } from './countPoints';\nimport { getMaxCountOnThisDirection } from './getMaxCountOnThisDirection';\n\nconst tryAndCalculateResult = (\n  myExistingPositions,\n  opponentExistingPositions,\n  computerPointAttempt,\n  direction\n) => {\n  let firstAnalysisResult = {};\n\n  const maxCountOnThisDirection = getMaxCountOnThisDirection(\n    computerPointAttempt,\n    opponentExistingPositions,\n    direction,\n    1\n  );\n\n  if (maxCountOnThisDirection < 5) {\n    return null;\n  }\n  if (maxCountOnThisDirection === 5) {\n    firstAnalysisResult = {\n      count: 1,\n      point: computerPointAttempt,\n      direction,\n      aliveState: ALIVE_STATES.HALF_ALIVE,\n    };\n  } else {\n    firstAnalysisResult = {\n      count: 1,\n      point: computerPointAttempt,\n      direction,\n      aliveState: ALIVE_STATES.ALIVE,\n    };\n  }\n\n  firstAnalysisResult = countPoints(\n    myExistingPositions,\n    opponentExistingPositions,\n    computerPointAttempt,\n    firstAnalysisResult,\n    direction,\n    COUNT_DIRECTION.FORWARD\n  );\n  firstAnalysisResult = countPoints(\n    myExistingPositions,\n    opponentExistingPositions,\n    computerPointAttempt,\n    firstAnalysisResult,\n    direction,\n    COUNT_DIRECTION.BACKWARD\n  );\n\n  if (\n    firstAnalysisResult.count <= 1 ||\n    (firstAnalysisResult.count === 2 && firstAnalysisResult.aliveState === ALIVE_STATES.HALF_ALIVE)\n  ) {\n    return null;\n  }\n\n  return firstAnalysisResult;\n};\n\nconst addToFirstAnalysisResult = (firstAnalysisResult, firstResultMap) => {\n  const { point } = firstAnalysisResult;\n\n  if (firstResultMap.has(point)) {\n    firstResultMap.get(point).push(firstAnalysisResult);\n  } else {\n    const list = [firstAnalysisResult];\n    firstResultMap.set(point, list);\n  }\n};\n\nexport const applyFirstAnalysis = (\n  computerExistingPositions,\n  humanExistingPositions,\n  allEmptyPoints,\n  range,\n  computerFirstResultMap,\n  humanFirstResultMap\n) => {\n  let computerPointAttempt = null;\n  let humanPointAttempt = null;\n  let x;\n  let y;\n  let firstAnalysisResult;\n\n  for (let i = 0; i < allEmptyPoints.length; i += 1) {\n    computerPointAttempt = allEmptyPoints[i];\n    x = computerPointAttempt.xIndex;\n    y = computerPointAttempt.yIndex;\n\n    if (x < range.rangeMinX || x > range.rangeMaxX || y < range.rangeMinY || y > range.rangeMaxY) {\n      continue;\n    }\n\n    firstAnalysisResult = tryAndCalculateResult(\n      computerExistingPositions,\n      humanExistingPositions,\n      computerPointAttempt,\n      DIRECTIONS.HORIZONTAL\n    );\n    computerPointAttempt.xIndex = x;\n    computerPointAttempt.yIndex = y;\n    if (firstAnalysisResult !== null) {\n      if (firstAnalysisResult.count === 5) {\n        return computerPointAttempt;\n      }\n      addToFirstAnalysisResult(firstAnalysisResult, computerFirstResultMap);\n    }\n\n    firstAnalysisResult = tryAndCalculateResult(\n      computerExistingPositions,\n      humanExistingPositions,\n      computerPointAttempt,\n      DIRECTIONS.VERTICAL\n    );\n    computerPointAttempt.xIndex = x;\n    computerPointAttempt.yIndex = y;\n    if (firstAnalysisResult !== null) {\n      if (firstAnalysisResult.count === 5) {\n        return computerPointAttempt;\n      }\n      addToFirstAnalysisResult(firstAnalysisResult, computerFirstResultMap);\n    }\n\n    firstAnalysisResult = tryAndCalculateResult(\n      computerExistingPositions,\n      humanExistingPositions,\n      computerPointAttempt,\n      DIRECTIONS.DIAGONAL_TOPLEFT_BOTTOMRIGHT\n    );\n    computerPointAttempt.xIndex = x;\n    computerPointAttempt.yIndex = y;\n    if (firstAnalysisResult !== null) {\n      if (firstAnalysisResult.count === 5) {\n        return computerPointAttempt;\n      }\n      addToFirstAnalysisResult(firstAnalysisResult, computerFirstResultMap);\n    }\n\n    firstAnalysisResult = tryAndCalculateResult(\n      computerExistingPositions,\n      humanExistingPositions,\n      computerPointAttempt,\n      DIRECTIONS.DIAGONAL_TOPRIGHT_BOTTOMLEFT\n    );\n    computerPointAttempt.xIndex = x;\n    computerPointAttempt.yIndex = y;\n    if (firstAnalysisResult !== null) {\n      if (firstAnalysisResult.count === 5) {\n        return computerPointAttempt;\n      }\n      addToFirstAnalysisResult(firstAnalysisResult, computerFirstResultMap);\n    }\n\n    // opposite direction of anaylsis, human side\n    firstAnalysisResult = tryAndCalculateResult(\n      humanExistingPositions,\n      computerExistingPositions,\n      computerPointAttempt,\n      DIRECTIONS.HORIZONTAL\n    );\n    computerPointAttempt.xIndex = x;\n    computerPointAttempt.yIndex = y;\n    if (firstAnalysisResult !== null) {\n      if (firstAnalysisResult.count === 5) {\n        humanPointAttempt = computerPointAttempt;\n      }\n      addToFirstAnalysisResult(firstAnalysisResult, humanFirstResultMap);\n    }\n\n    firstAnalysisResult = tryAndCalculateResult(\n      humanExistingPositions,\n      computerExistingPositions,\n      computerPointAttempt,\n      DIRECTIONS.VERTICAL\n    );\n    computerPointAttempt.xIndex = x;\n    computerPointAttempt.yIndex = y;\n    if (firstAnalysisResult !== null) {\n      if (firstAnalysisResult.count === 5) {\n        humanPointAttempt = computerPointAttempt;\n      }\n      addToFirstAnalysisResult(firstAnalysisResult, humanFirstResultMap);\n    }\n\n    firstAnalysisResult = tryAndCalculateResult(\n      humanExistingPositions,\n      computerExistingPositions,\n      computerPointAttempt,\n      DIRECTIONS.DIAGONAL_TOPLEFT_BOTTOMRIGHT\n    );\n    computerPointAttempt.xIndex = x;\n    computerPointAttempt.yIndex = y;\n    if (firstAnalysisResult !== null) {\n      if (firstAnalysisResult.count === 5) {\n        humanPointAttempt = computerPointAttempt;\n      }\n      addToFirstAnalysisResult(firstAnalysisResult, humanFirstResultMap);\n    }\n\n    firstAnalysisResult = tryAndCalculateResult(\n      humanExistingPositions,\n      computerExistingPositions,\n      computerPointAttempt,\n      DIRECTIONS.DIAGONAL_TOPRIGHT_BOTTOMLEFT\n    );\n    computerPointAttempt.xIndex = x;\n    computerPointAttempt.yIndex = y;\n    if (firstAnalysisResult !== null) {\n      if (firstAnalysisResult.count === 5) {\n        humanPointAttempt = computerPointAttempt;\n      }\n      addToFirstAnalysisResult(firstAnalysisResult, humanFirstResultMap);\n    }\n  }\n\n  return humanPointAttempt;\n};\n","/* eslint-disable complexity */\nconst analysisBestPoint = (mySecondAnalysisResults, yourSecondAnalysisResults) => {\n  if (mySecondAnalysisResults.length !== 0) {\n    if (mySecondAnalysisResults.length === 1) {\n      return mySecondAnalysisResults[0].position;\n    }\n    for (let i = 0; i < yourSecondAnalysisResults.length; i += 1) {\n      const yourResult = yourSecondAnalysisResults[i];\n      const commonBestPoint = mySecondAnalysisResults.find(\n        (myResult) =>\n          myResult.position.xIndex === yourResult.position.xIndex &&\n          myResult.position.yIndex === yourResult.position.yIndex\n      );\n      if (commonBestPoint) {\n        return commonBestPoint.position;\n      }\n    }\n    return mySecondAnalysisResults[0].position;\n  }\n\n  return null;\n};\n\nconst getBestPoint = (analysisResults) => {\n  let bestPoint = analysisBestPoint(\n    analysisResults.computerDouble3Alives,\n    analysisResults.humanSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  bestPoint = analysisBestPoint(\n    analysisResults.computer3Alives,\n    analysisResults.humanSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  bestPoint = analysisBestPoint(\n    analysisResults.humanDouble3Alives,\n    analysisResults.computerSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  bestPoint = analysisBestPoint(\n    analysisResults.human3Alives,\n    analysisResults.computerSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  bestPoint = analysisBestPoint(\n    analysisResults.computerDouble2Alives,\n    analysisResults.humanSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  bestPoint = analysisBestPoint(\n    analysisResults.computer2Alives,\n    analysisResults.humanSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  bestPoint = analysisBestPoint(\n    analysisResults.computer3HalfAlives,\n    analysisResults.humanSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  bestPoint = analysisBestPoint(\n    analysisResults.human4HalfAlives,\n    analysisResults.computerSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  bestPoint = analysisBestPoint(\n    analysisResults.humanDouble2Alives,\n    analysisResults.computerSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  bestPoint = analysisBestPoint(\n    analysisResults.human2Alives,\n    analysisResults.computerSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  bestPoint = analysisBestPoint(\n    analysisResults.human3HalfAlives,\n    analysisResults.computerSecondResults\n  );\n  if (bestPoint) return bestPoint;\n\n  return null;\n};\n\nexport const applyThirdAnalysis = (analysisResults) => {\n  if (analysisResults.computer4HalfAlives.length !== 0) {\n    return analysisResults.computer4HalfAlives[0].position;\n  }\n\n  let bestPoint = analysisBestPoint(\n    analysisResults.human4Alives,\n    analysisResults.computerSecondResults\n  );\n  if (bestPoint) {\n    return bestPoint;\n  }\n\n  bestPoint = getBestPoint(analysisResults);\n  if (bestPoint) {\n    return bestPoint;\n  }\n\n  return analysisResults.computerSecondResults[0].position;\n};\n","/* eslint-disable no-continue */\n/* eslint-disable complexity */\nimport { getFirstPosition } from '../aiLogics/getFirstPosition';\nimport { initialiseAnalysisRange } from '../aiLogics/initialiseAnalysisRange';\nimport { CHESS_TYPES } from '../constants';\nimport { applyFirstAnalysis } from '../aiLogics/applyFirstAnalysis';\nimport { applySecondComputerAnalysis } from '../aiLogics/applySecondComputerAnalysis';\nimport { applySecondHumanAnalysis } from '../aiLogics/applySecondHumanAnalysis';\nimport { applyThirdAnalysis } from '../aiLogics/applyThirdAnalysis';\n\nconst getAllEmptyPoints = (chessMap) => {\n  return chessMap\n    .filter((chess) => chess.chessType === CHESS_TYPES.EMPTY)\n    .map((chess) => ({\n      xIndex: parseInt(chess.xIndex, 10),\n      yIndex: parseInt(chess.yIndex, 10),\n    }));\n};\n\nlet computerFirstResultMap = new Map();\nlet humanFirstResultMap = new Map();\n\nconst analysisResults = {};\n\nconst initAnalysisResult = () => {\n  computerFirstResultMap = new Map();\n  humanFirstResultMap = new Map();\n\n  analysisResults.computerSecondResults = [];\n  analysisResults.humanSecondResults = [];\n\n  analysisResults.computer4HalfAlives = [];\n  analysisResults.computerDouble3Alives = [];\n  analysisResults.computer3Alives = [];\n  analysisResults.computerDouble2Alives = [];\n  analysisResults.computer2Alives = [];\n  analysisResults.computer3HalfAlives = [];\n\n  analysisResults.human4Alives = [];\n  analysisResults.human4HalfAlives = [];\n  analysisResults.humanDouble3Alives = [];\n  analysisResults.human3Alives = [];\n  analysisResults.humanDouble2Alives = [];\n  analysisResults.human2Alives = [];\n  analysisResults.human3HalfAlives = [];\n};\n\nconst startAnalysis = (aiChessType, currentChess, chessOrder, chessMap) => {\n  if (chessOrder.length === 1) {\n    return getFirstPosition(currentChess);\n  }\n\n  // 1. initRange to search\n  const range = initialiseAnalysisRange(chessOrder, chessMap);\n\n  // 2. init analysis result\n  initAnalysisResult();\n\n  const allEmptyPoints = getAllEmptyPoints(chessMap);\n\n  const humanChessType = aiChessType === CHESS_TYPES.BLACK ? CHESS_TYPES.WHITE : CHESS_TYPES.BLACK;\n  const humanExistingPositions = chessOrder\n    .filter((chess) => chess.chessType === humanChessType)\n    .map((chess) => ({ xIndex: chess.xIndex, yIndex: chess.yIndex }));\n  const computerExistingPositions = chessOrder\n    .filter((chess) => chess.chessType === aiChessType)\n    .map((chess) => ({ xIndex: chess.xIndex, yIndex: chess.yIndex }));\n\n  // 3. start first analysis\n  let bestPoint = applyFirstAnalysis(\n    computerExistingPositions,\n    humanExistingPositions,\n    allEmptyPoints,\n    range,\n    computerFirstResultMap,\n    humanFirstResultMap\n  );\n  if (bestPoint !== null) {\n    console.log('This position is the most crucial, must be taken!');\n    return bestPoint;\n  }\n\n  console.log('analysisResults before second round', analysisResults);\n\n  // 4. start computer second analysis\n  bestPoint = applySecondComputerAnalysis(computerFirstResultMap, analysisResults);\n  if (bestPoint !== null) {\n    console.log('Almost winning, must take this position');\n    return bestPoint;\n  }\n\n  // 5. start human second analysis\n  bestPoint = applySecondHumanAnalysis(humanFirstResultMap, analysisResults);\n  if (bestPoint !== null) {\n    console.log('Almost losing, must take this position');\n    return bestPoint;\n  }\n\n  console.log('analysisResults before third round', analysisResults);\n\n  // 6. start third analysis (final)\n  return applyThirdAnalysis(analysisResults);\n};\n\nexport const applyConditionalAiLogic = (chessOrder, chessMap) => {\n  const parsedChessOrder = chessOrder.map((chess) => ({\n    ...chess,\n    xIndex: parseInt(chess.xIndex, 10),\n    yIndex: parseInt(chess.yIndex, 10),\n  }));\n  const currentChess = parsedChessOrder[parsedChessOrder.length - 1];\n  const aiChessType =\n    currentChess.chessType === CHESS_TYPES.BLACK ? CHESS_TYPES.WHITE : CHESS_TYPES.BLACK;\n\n  const nextPosition = startAnalysis(aiChessType, currentChess, parsedChessOrder, chessMap);\n\n  return {\n    xIndex: `${nextPosition.xIndex}`,\n    yIndex: `${nextPosition.yIndex}`,\n    chessType: aiChessType,\n  };\n};\n","import { BOARD_SIZE } from '../constants';\n\nexport const getFirstPosition = (currentChess) => {\n  if (\n    currentChess.xIndex === BOARD_SIZE.MIN_X ||\n    currentChess.yIndex === BOARD_SIZE.MIN_Y ||\n    currentChess.xIndex === BOARD_SIZE.MAX_X ||\n    currentChess.yIndex === BOARD_SIZE.MAX_Y\n  ) {\n    return {\n      xIndex: `${BOARD_SIZE.MAX_X / 2}`,\n      yIndex: `${BOARD_SIZE.MAX_Y / 2}`,\n    };\n  }\n  const nextX = `${currentChess.xIndex - 1}`;\n  const nextY = `${currentChess.yIndex}`;\n\n  return {\n    xIndex: nextX,\n    yIndex: nextY,\n  };\n};\n","import { BOARD_SIZE } from '../constants';\n\nexport const initialiseAnalysisRange = (chessOrder) => {\n  const ANAYSIS_RANGE = 1;\n  const currentRange = {\n    rangeMinX: 0,\n    rangeMinY: 0,\n    rangeMaxX: 0,\n    rangeMaxY: 0,\n  };\n  currentRange.rangeMinX = chessOrder[0].xIndex - ANAYSIS_RANGE;\n  currentRange.rangeMinY = chessOrder[0].yIndex - ANAYSIS_RANGE;\n  currentRange.rangeMaxX = chessOrder[0].xIndex + ANAYSIS_RANGE;\n  currentRange.rangeMaxY = chessOrder[0].yIndex + ANAYSIS_RANGE;\n\n  chessOrder.forEach((chess) => {\n    if (chess.xIndex - ANAYSIS_RANGE < currentRange.rangeMinX) {\n      currentRange.rangeMinX = chess.xIndex - ANAYSIS_RANGE;\n    }\n    if (chess.yIndex - ANAYSIS_RANGE < currentRange.rangeMinY) {\n      currentRange.rangeMinY = chess.yIndex - ANAYSIS_RANGE;\n    }\n    if (chess.xIndex + ANAYSIS_RANGE > currentRange.rangeMaxX) {\n      currentRange.rangeMaxX = chess.xIndex + ANAYSIS_RANGE;\n    }\n    if (chess.yIndex + ANAYSIS_RANGE > currentRange.rangeMaxY) {\n      currentRange.rangeMaxY = chess.yIndex + ANAYSIS_RANGE;\n    }\n  });\n\n  currentRange.rangeMinX =\n    currentRange.rangeMinX < BOARD_SIZE.MIN_X ? BOARD_SIZE.MIN_X : currentRange.rangeMinX;\n  currentRange.rangeMinY =\n    currentRange.rangeMinY < BOARD_SIZE.MIN_Y ? BOARD_SIZE.MIN_Y : currentRange.rangeMinY;\n  currentRange.rangeMaxX =\n    currentRange.rangeMaxX > BOARD_SIZE.MAX_X ? BOARD_SIZE.MAX_X : currentRange.rangeMaxX;\n  currentRange.rangeMaxY =\n    currentRange.rangeMaxY > BOARD_SIZE.MAX_Y ? BOARD_SIZE.MAX_Y : currentRange.rangeMaxY;\n  return currentRange;\n};\n","/* eslint-disable complexity */\nimport { ALIVE_STATES } from '../constants';\n\n/* eslint-disable no-restricted-syntax */\nexport const applySecondComputerAnalysis = (firstResultMap, analysisResults) => {\n  let secondResultsInstance = null;\n\n  for (const key of firstResultMap.keys()) {\n    secondResultsInstance = {\n      alive4: 0,\n      alive3: 0,\n      halfAlive4: 0,\n      halfAlive3: 0,\n      alive2: 0,\n      position: key,\n    };\n    const firstResults = firstResultMap.get(key);\n\n    for (let i = 0; i < firstResults.length; i += 1) {\n      const result = firstResults[i];\n      if (result.count === 4) {\n        if (result.aliveState === ALIVE_STATES.ALIVE) {\n          return result.point;\n        }\n        secondResultsInstance.alive4 += 1;\n        analysisResults.computer4HalfAlives.push(secondResultsInstance);\n      } else if (result.count === 3) {\n        if (result.aliveState === ALIVE_STATES.ALIVE) {\n          secondResultsInstance.alive3 += 1;\n          if (secondResultsInstance.alive3 === 1) {\n            analysisResults.computer3Alives.push(secondResultsInstance);\n          } else {\n            analysisResults.computerDouble3Alives.push(secondResultsInstance);\n          }\n        } else {\n          secondResultsInstance.halfAlive3 += 1;\n          analysisResults.computer3HalfAlives.push(secondResultsInstance);\n        }\n      } else {\n        secondResultsInstance.alive2 += 1;\n        if (secondResultsInstance.alive2 === 1) {\n          analysisResults.computer2Alives.push(secondResultsInstance);\n        }\n        analysisResults.computerDouble2Alives.push(secondResultsInstance);\n      }\n    }\n\n    analysisResults.computerSecondResults.push(secondResultsInstance);\n  }\n\n  return null;\n};\n","/* eslint-disable complexity */\nimport { ALIVE_STATES } from '../constants';\n\n/* eslint-disable no-restricted-syntax */\nexport const applySecondHumanAnalysis = (firstResultMap, analysisResults) => {\n  let secondResultsInstance = null;\n\n  for (const key of firstResultMap.keys()) {\n    secondResultsInstance = {\n      alive4: 0,\n      alive3: 0,\n      halfAlive4: 0,\n      halfAlive3: 0,\n      alive2: 0,\n      position: key,\n    };\n    const firstResults = firstResultMap.get(key);\n\n    for (let i = 0; i < firstResults.length; i += 1) {\n      const result = firstResults[i];\n      if (result.count === 4) {\n        if (result.aliveState === ALIVE_STATES.ALIVE) {\n          analysisResults.human4Alives.push(secondResultsInstance);\n        } else {\n          secondResultsInstance.halfAlive4 += 1;\n          analysisResults.human4HalfAlives.push(secondResultsInstance);\n        }\n      } else if (result.count === 3) {\n        if (result.aliveState === ALIVE_STATES.ALIVE) {\n          secondResultsInstance.alive3 += 1;\n          if (secondResultsInstance.alive3 === 1) {\n            analysisResults.human3Alives.push(secondResultsInstance);\n          } else {\n            analysisResults.humanDouble3Alives.push(secondResultsInstance);\n          }\n        } else {\n          secondResultsInstance.halfAlive3 += 1;\n          analysisResults.human3HalfAlives.push(secondResultsInstance);\n        }\n      } else {\n        secondResultsInstance.alive2 += 1;\n        if (secondResultsInstance.alive2 === 1) {\n          analysisResults.human2Alives.push(secondResultsInstance);\n        }\n        analysisResults.humanDouble2Alives.push(secondResultsInstance);\n      }\n    }\n\n    analysisResults.humanSecondResults.push(secondResultsInstance);\n  }\n\n  return null;\n};\n","import React, { useEffect } from 'react';\nimport PropTypes from 'prop-types';\nimport { Chess } from './components';\nimport { ChessBoardContainer } from './chessBoardStyles';\nimport { applyConditionalAiLogic } from '../../utils/functions/applyAiLogic';\nimport { reverseChessTurn } from '../../utils/functions';\n\nconst ChessBoard = ({\n  chessOrder,\n  chessMap,\n  chessTurn,\n  isWhite,\n  hasWon,\n  setChessOrder,\n  setChessTurn,\n}) => {\n  useEffect(() => {\n    const placingOrder = isWhite ? chessOrder.length % 2 === 0 : chessOrder.length % 2 === 1;\n\n    if (placingOrder && !hasWon) {\n      const aiChess = applyConditionalAiLogic(chessOrder, chessMap);\n      setChessOrder((prevState) => [...prevState, aiChess]);\n      reverseChessTurn(setChessTurn);\n    }\n  }, [chessOrder, chessMap, setChessOrder, setChessTurn, isWhite, hasWon]);\n\n  return (\n    <ChessBoardContainer>\n      {chessMap.map((chess) => (\n        <Chess\n          key={`${chess.chessType}-${chess.xIndex}-${chess.yIndex}`}\n          chessType={chess.chessType}\n          chessTurn={chessTurn}\n          xIndex={chess.xIndex}\n          yIndex={chess.yIndex}\n          hasWon={hasWon}\n          setChessOrder={setChessOrder}\n          setChessTurn={setChessTurn}\n        />\n      ))}\n    </ChessBoardContainer>\n  );\n};\n\nChessBoard.propTypes = {\n  chessMap: PropTypes.arrayOf(PropTypes.shape()).isRequired,\n  chessTurn: PropTypes.string.isRequired,\n  isWhite: PropTypes.bool.isRequired,\n  hasWon: PropTypes.bool.isRequired,\n  setChessOrder: PropTypes.func.isRequired,\n  setChessTurn: PropTypes.func.isRequired,\n};\n\nexport default ChessBoard;\n","import styled from 'styled-components';\nimport { colors } from '../../utils/styleVars';\n\nconst sizes = {\n  borderWidth: '3px',\n};\n\nexport const DialogContainer = styled.div`\n  align-items: center;\n  border-style: solid;\n  border-color: ${colors.black};\n  border-width: ${sizes.borderWidth};\n  display: flex;\n  flex-direction: column;\n  height: 30vh;\n  justify-content: center;\n  left: 100vh;\n  position: absolute;\n  top: 0;\n  width: calc(100vw - 100vh - 2 * ${sizes.borderWidth});\n`;\n\nexport const VictoryMessage = styled.div`\n  color: ${colors.black};\n  font-size: 1.6rem;\n  font-weight: 300;\n  margin: 1vh;\n  text-align: center;\n`;\n\nexport const ResetButton = styled.button`\n  border-style: none;\n  background-color: ${colors.black};\n  color: ${colors.white};\n  font-size: 1.6rem;\n  padding: 1vh;\n  &:hover {\n    background-color: ${colors.white};\n    color: ${colors.black};\n  }\n`;\n","import React from 'react';\nimport PropTypes from 'prop-types';\nimport { DialogContainer, VictoryMessage, ResetButton } from './dialogStyles';\nimport { reverseChessTurn } from '../../utils/functions';\nimport { getDefaultChessOrder, getFirstTurnColor } from '../../utils/constants';\n\nconst Dialog = ({ chessTypeHasWon, socket, isWhite, setChessOrder, setChessTurn }) => {\n  const handleReset = () => {\n    if (socket) {\n      socket.emit('resetChessMap');\n      return;\n    }\n    setChessOrder(getDefaultChessOrder(isWhite));\n    setChessTurn(getFirstTurnColor(isWhite));\n  };\n\n  const handleUndo = () => {\n    if (socket) {\n      socket.emit('undoChessAction');\n      return;\n    }\n    setChessOrder((prevState) => {\n      prevState.pop();\n      return [...prevState];\n    });\n    reverseChessTurn(setChessTurn);\n  };\n\n  return (\n    <DialogContainer>\n      {chessTypeHasWon && <VictoryMessage>{`${chessTypeHasWon} has won`}</VictoryMessage>}\n      <ResetButton onClick={handleReset}>Reset</ResetButton>\n      <ResetButton onClick={handleUndo}>Undo</ResetButton>\n    </DialogContainer>\n  );\n  // Timer\n};\n\nDialog.propTypes = {\n  chessTypeHasWon: PropTypes.string,\n  isWhite: PropTypes.bool.isRequired,\n  setChessOrder: PropTypes.func.isRequired,\n  setChessTurn: PropTypes.func.isRequired,\n};\n\nDialog.defaultProps = {\n  chessTypeHasWon: '',\n};\n\nexport default Dialog;\n","import styled from 'styled-components';\n\nexport const OuterContainer = styled.div`\n  display: flex;\n  justify-content: center;\n  text-align: center;\n  height: 100vh;\n  align-items: center;\n  background-color: #1a1a1d;\n\n  @media (min-width: 320px) and (max-width: 480px) {\n    height: 100%;\n  }\n`;\n\nexport const InnerContainer = styled.div`\n  width: 20%;\n\n  @media (min-width: 320px) and (max-width: 480px) {\n    width: 90%;\n  }\n`;\n\nexport const Input = styled.input`\n  border-radius: 0;\n  padding: 15px 20px;\n  width: 100%;\n  margin-bottom: 20px;\n`;\n\nexport const Heading = styled.h1`\n  color: white;\n  font-size: 2.5em;\n  padding-bottom: 10px;\n  border-bottom: 2px solid white;\n`;\n\nexport const Button = styled.button`\n  color: #fff !important;\n  text-transform: uppercase;\n  text-decoration: none;\n  background: #2979ff;\n  padding: 20px;\n  border-radius: 5px;\n  display: inline-block;\n  border: none;\n  width: 100%;\n  margin-top: 20px;\n\n  :focus {\n    outline: 0;\n  }\n`;\n","import queryString from 'query-string';\nimport { useLocation, HashRouter as Router, Route, Routes } from 'react-router-dom';\nimport React, { useEffect, useState } from 'react';\nimport io from 'socket.io-client';\nimport { Chat, MultiChessBoard, Dialog, Entry, SingleChessBoard } from './components';\nimport { CHESS_TYPES, getDefaultChessOrder, getFirstTurnColor } from './utils/constants';\nimport { setEmptyChessMap, updateChessMap, getWinningChessType } from './utils/functions';\n\nconst ENDPOINT = 'http://18.206.247.59:4000';\nlet socket;\n\nconst MultiplayerApp = () => {\n  const location = useLocation();\n  const FIRST_TURN_COLOR = CHESS_TYPES.BLACK;\n  const [chessOrder, setChessOrder] = useState([]);\n  const [chessTurn, setChessTurn] = useState(FIRST_TURN_COLOR);\n  const [name, setName] = useState('');\n  const chessMap = setEmptyChessMap();\n  const chessTypeHasWon = getWinningChessType(chessOrder);\n  updateChessMap(chessOrder, chessMap);\n\n  useEffect(() => {\n    const { name: urlName, room: urlRoom } = queryString.parse(location.search);\n    socket = io(ENDPOINT);\n    setName(urlName);\n    socket.emit('join', { name: urlName, room: urlRoom }, (error) => {\n      if (error) alert(error);\n    });\n  }, [location.search]);\n\n  return (\n    <>\n      <MultiChessBoard\n        firstTurnColor={FIRST_TURN_COLOR}\n        chessMap={chessMap}\n        chessTurn={chessTurn}\n        hasWon={!!chessTypeHasWon}\n        setChessOrder={setChessOrder}\n        setChessTurn={setChessTurn}\n        socket={socket}\n      />\n      <Dialog chessTypeHasWon={chessTypeHasWon} socket={socket} />\n      <Chat name={name} socket={socket} />\n    </>\n  );\n};\n\nconst SingleplayerApp = ({ isWhite = false }) => {\n  const FIRST_TURN_COLOR = getFirstTurnColor(isWhite);\n  const [chessOrder, setChessOrder] = useState(getDefaultChessOrder(isWhite));\n  const [chessTurn, setChessTurn] = useState(FIRST_TURN_COLOR);\n  const chessMap = setEmptyChessMap();\n  const chessTypeHasWon = getWinningChessType(chessOrder);\n  updateChessMap(chessOrder, chessMap);\n\n  return (\n    <>\n      <SingleChessBoard\n        chessOrder={chessOrder}\n        chessMap={chessMap}\n        chessTurn={chessTurn}\n        isWhite={isWhite}\n        hasWon={!!chessTypeHasWon}\n        setChessOrder={setChessOrder}\n        setChessTurn={setChessTurn}\n      />\n      <Dialog\n        chessTypeHasWon={chessTypeHasWon}\n        isWhite={isWhite}\n        setChessOrder={setChessOrder}\n        setChessTurn={setChessTurn}\n      />\n    </>\n  );\n};\n\nconst RouterApp = () => {\n  return (\n    <Router>\n      <Routes>\n        <Route path=\"/entry\" element={<Entry />} />\n        <Route path=\"/game\" element={<MultiplayerApp />} />\n        <Route path=\"/white\" element={<SingleplayerApp isWhite />} />\n        <Route exact path=\"/\" element={<SingleplayerApp />} />\n      </Routes>\n    </Router>\n  );\n};\n\nexport default RouterApp;\n","import React, { useState } from 'react';\nimport { Link } from 'react-router-dom';\nimport { Button, Heading, InnerContainer, Input, OuterContainer } from './entryStyles';\n\nconst Entry = () => {\n  const [name, setName] = useState('');\n  const [room, setRoom] = useState('');\n\n  return (\n    <OuterContainer>\n      <InnerContainer>\n        <Heading>Join</Heading>\n        <div>\n          <Input placeholder=\"Name\" type=\"text\" onChange={(event) => setName(event.target.value)} />\n        </div>\n        <div>\n          <Input placeholder=\"Room\" type=\"text\" onChange={(event) => setRoom(event.target.value)} />\n        </div>\n        <Link\n          onClick={(e) => (!name || !room ? e.preventDefault() : null)}\n          to={`/game?name=${name}&room=${room}`}\n        >\n          <Button type=\"submit\">Join</Button>\n        </Link>\n      </InnerContainer>\n    </OuterContainer>\n  );\n};\n\nexport default Entry;\n","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}